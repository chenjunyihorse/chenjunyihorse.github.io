<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="FlyingLandlord's Blog" href="http://flyinglandlord.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="FlyingLandlord's Blog" href="http://flyinglandlord.github.io/atom.xml"><link rel="alternate" type="application/json" title="FlyingLandlord's Blog" href="http://flyinglandlord.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="北航操作系统,OS,Lab5"><link rel="canonical" href="http://flyinglandlord.github.io/2022/06/15/BUAA-OS-2022/lab5/doc-lab5/"><title>BUAA-OS Lab5 实验总结 - 北航操作系统 | Test Blog = FlyingLandlord's Blog</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">BUAA-OS Lab5 实验总结</h1><div class="meta"><span class="item" title="创建时间：2022-06-15 20:25:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-06-15T20:25:00+08:00">2022-06-15</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Test Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/assets/BangD.jpg"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="item" rel="index" title="分类于 北航操作系统"><span itemprop="name">北航操作系统</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://flyinglandlord.github.io/2022/06/15/BUAA-OS-2022/lab5/doc-lab5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="FL"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="FlyingLandlord's Blog"></span><div class="body md" itemprop="articleBody"><h1 id="lab-5-实验报告"><a class="anchor" href="#lab-5-实验报告">#</a> lab-5 实验报告</h1><h2 id="实验思考题"><a class="anchor" href="#实验思考题">#</a> 实验思考题</h2><h3 id="thinking-51"><a class="anchor" href="#thinking-51">#</a> Thinking 5.1</h3><p>查阅资料，了解 Linux/Unix 的 /proc 文件系统是什么？有什么作用？ Windows 操作系统又是如何实现这些功能的？proc 文件系统这样的设计有什么好处和可以改进的地方？</p><p><strong>答案</strong></p><p>/proc 文件系统是一个虚拟文件系统，通过它可以使用一种新的方法在 Linux 内核空间和用户间之间进行通信。在 /proc 文件系统中，我们可以将对虚拟文件的读写作为与内核中实体进行通信的一种手段，但是与普通文件不同的是，这些虚拟文件的内容都是动态创建的。其只存在于内存中，而不占用外存空间。它提供了新的一种在用户空间和内核空间中进行通信的模式。用户和应用程序可以通过 proc 得到系统的信息，并可以改变内核的某些参数，这个过程是动态的，随着内核参数的改变而改变。</p><p>Win32 API 是 Windows 操作系统内核与应用程序之间的界面，它将内核提供的功能进行函数包装，应用程序通过调用相关函数而获得相应的系统功能，相关函数接着调用系统服务接口，最后由系统服务接口调用内核模式中的服务例程。</p><p>好处：为了降低内核调试和学习的难度，内核开发者们在内核中添加了一些属性专门用于调试内核，proc 文件系统就是一个尝试。我们通过实时的观察 /proc/xxx 文件，来观看内核中特定数据结构的值。在我们添加一个新功能的前后来对比，就可以知道这个新功能产生的影响对还是不对。/proc 文件系统的设计将对内核信息的访问交互抽象为对文件的访问修改，简化了交互过程。</p><p>可以改进的地方：访问的容易必将带来安全性的隐患，程序可能获取到一些或者可能会很容易修改一些很重要的内核设置，对内核造成损害</p><h3 id="thinking-52"><a class="anchor" href="#thinking-52">#</a> Thinking 5.2</h3><p>如果我们通过 kseg0 读写设备，我们对于设备的写入会缓存到 Cache 中。通过 kseg0 访问设备是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请你思考：这么做这会引起什么问题？对于不同种类的设备（如我们提到的串口设备和 IDE 磁盘）的操作会有差异吗？可以从缓存的性质和缓存刷新的策略来考虑。</p><p><strong>答案</strong></p><p>外设更新后对内存也进行了更新，但是 cache 中的没有被更新，如果我们通过 kseg0 来访问设备，那么就会导致总是优先通过 cache 获取缓存的数据，而缓存的数据没有更新，从而导致错误，即我们获取的数据并不是最新的。</p><p>自盘作为块设备，总是以块为单位进行读写，而且会经常进行读写，写的时候相应的内存会标记为 dirty，从而写回，更新缓存，因此这种错误对磁盘出现概率较小；但是与之相反，串口设备等字符型设备就很容易发生这种错误。</p><h3 id="thinking-53"><a class="anchor" href="#thinking-53">#</a> Thinking 5.3</h3><p>比较 MOS 操作系统的文件控制块和 Unix/Linux 操作系统的 inode 及相关概念，试述二者的不同之处。</p><p><strong>答案</strong></p><p>现代 Linux 使用的应该是一种日志型文件系统，是如下图有 log 的，添加或删除文件是通过修改 log，然后最后一起同步时写入的，这样会避免突然断电等导致的数据不一致的问题。</p><p><img data-src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20220609225215151.png" alt="image-20220609225215151"></p><p>回到正题，inode 实质上跟我们的文件控制块没有太大的差别，都是类似于下图的描述文件包含的磁盘块的结构，与我们 MOS 不同的是，为了支持更大的文件大小，可能 inode 会有多级间接块</p><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/09/Ext2-inode.svg/1280px-Ext2-inode.svg.png" alt="img"></p><p>而且相较于我们的 MOS，Linux 的 inode 中的字段更多，保存的信息也更多</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Linux 0.11</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">m_inode</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> i_mode<span class="token punctuation">;</span><span class="token comment">/* 文件类型和属性，ls 查看的结果，比如 drwx------*/</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> i_uid<span class="token punctuation">;</span><span class="token comment">/* 文件宿主 id*/</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> i_size<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> i_mtime<span class="token punctuation">;</span><span class="token comment">/* 文件内容上一次变动的时间 */</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> i_gid<span class="token punctuation">;</span><span class="token comment">/*groupid：宿主所在的组 id*/</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> i_nlinks<span class="token punctuation">;</span> <span class="token comment">/* 链接数：有多少个其他的文件夹链接到这里 */</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> i_zone<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* 文件映射的逻辑块号 */</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">/* these are in memory also */</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span> i_wait<span class="token punctuation">;</span><span class="token comment">/* 等待该 inode 节点的进程队列 */</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> i_atime<span class="token punctuation">;</span><span class="token comment">/* 文件上一次打开的时间 */</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> i_ctime<span class="token punctuation">;</span><span class="token comment">/* 文件的 inode 上一次变动的时间 */</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> i_dev<span class="token punctuation">;</span><span class="token comment">/* 设备号 */</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> i_num<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">/* 多少个进程在使用这个 inode*/</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> i_count<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> i_lock<span class="token punctuation">;</span><span class="token comment">/* 互斥锁 */</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> i_dirt<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> i_pipe<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> i_mount<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> i_seek<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token comment">/*</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    数据是否是最新的，或者说有效的，</pre></td></tr><tr><td data-num="25"></td><td><pre>    update 代表数据的有效性，dirt 代表文件是否需要回写，</pre></td></tr><tr><td data-num="26"></td><td><pre>    比如写入文件的时候，a 进程写入的时候，dirt 是 1，因为需要回写到硬盘，</pre></td></tr><tr><td data-num="27"></td><td><pre>    但是数据是最新的，update 是 1，这时候 b 进程读取这个文件的时候，可以从</pre></td></tr><tr><td data-num="28"></td><td><pre>    缓存里直接读取。</pre></td></tr><tr><td data-num="29"></td><td><pre>    */</pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> i_update<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>Linux 系统下 FCB 储存了文件的所有信息，但索引结点下的 FCB 进行了改进，除了文件名之外的文件描述信息都放到索引节点里，这样一来该结构体大小就可以匹配磁盘块的大小，大大提升文件检索速度。如此一来 inode 模块则封装了很多东西，例如 <code>i_op</code> 成员定义对目录相关的操作方法列表，譬如 <code>mkdir()</code> 系统调用会触发 <code>inode-&gt;i_op-&gt;mkdir()</code> 方法，而 link () 系统调用会触发 <code>inode-&gt;i_op-&gt;link()</code> 方法。而 <code>i_fop</code> 成员则定义了对打开文件后对文件的操作方法列表，譬如 <code>read()</code> 系统调用会触发 <code>inode-&gt;i_fop-&gt;read()</code> 方法，而 <code>write()</code> 系统调用会触发 <code>inode-&gt;i_fop-&gt;write()</code> 方法</p><p>而 MOS 作为微内核操作系统，文件操作均在用户态实现，有单独的文件服务进程，对文件的操作是依靠进程间通信来完成的，这一点与上述 Linux 通过系统调用直接进行不同</p><h3 id="thinking-54"><a class="anchor" href="#thinking-54">#</a> Thinking 5.4</h3><p>查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？</p><p><strong>答案</strong></p><ul><li>一个磁盘块中有 <code>FILE2BLK</code> = 16 个文件控制块</li><li>一个目录最多指向 1024 个磁盘块，因此一共目录中最多 1024*16=16384 个子文件</li><li>一个磁盘块大小是 4KB，使用二级索引机制，第二级是一个磁盘块，总共可以有 1024 个索引，所以单个文件是 1024 * 4KB = 4MB。</li></ul><h3 id="thinking-55"><a class="anchor" href="#thinking-55">#</a> Thinking 5.5</h3><p>请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？</p><p><strong>答案</strong></p><p>我们的 MOS 系统相当于把整个磁盘的块和文件系统服务进程的内存空间进行了一个一一映射，因此可用映射内存大小就应当是最大硬盘大小，简单计算可以得到用于映射的内存空间为 1GB，因此最大磁盘大小也应当为 1GB</p><h3 id="thinking-56"><a class="anchor" href="#thinking-56">#</a> Thinking 5.6</h3><p>如果将 DISKMAX 改成 0xC0000000, 超过用户空间，我们的文件系统还能正常工作吗？为什么？</p><p><strong>答案</strong></p><p>理论上来说，这个地址仅仅只是虚拟地址，跟物理页没有什么关系，看起来好像是可以的。</p><p><strong>其实并不是这样</strong>，MIPS 的地址翻译是极为特殊的，位于 kseg0 和 kseg1 等位置的虚拟地址不会经过 MMU，而是有一套单独的翻译规则，我们的文件系统是一个用户进程，对内核的高地址没有写的权限，所以不能正常工作</p><h3 id="thinking-57"><a class="anchor" href="#thinking-57">#</a> Thinking 5.7</h3><p>在 lab5 中， <code>fs/fs.h</code> 、 <code>include/fs.h</code> 等文件中出现了许多结构体和宏定义，写出你认为比较重要或难以理解的部分，并进行解释。</p><p><strong>答案</strong></p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// fs/fs.h</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">/* IDE disk number to look on for our file system */</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DISKNO</span>		<span class="token expression"><span class="token number">1</span></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BY2SECT</span>		<span class="token expression"><span class="token number">512</span>	</span><span class="token comment">/* Bytes per disk sector */</span></span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SECT2BLK</span>	<span class="token expression"><span class="token punctuation">(</span>BY2BLK<span class="token operator">/</span>BY2SECT<span class="token punctuation">)</span>	</span><span class="token comment">/* sectors to a block */</span></span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">/* Disk block n, when in memory, is mapped into the file system</span></pre></td></tr><tr><td data-num="9"></td><td><pre> * server's address space at DISKMAP+(n*BY2BLK). */</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DISKMAP</span>		<span class="token expression"><span class="token number">0x10000000</span></span></span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">/* Maximum disk size we can handle (1GB) */</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DISKMAX</span>		<span class="token expression"><span class="token number">0x40000000</span></span></span></pre></td></tr></table></figure><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// include/fs.h</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// Bytes per file system block - same as page size</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BY2BLK</span>		<span class="token expression">BY2PG</span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BIT2BLK</span>		<span class="token expression"><span class="token punctuation">(</span>BY2BLK<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// Maximum size of a filename (a single path component), including null</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXNAMELEN</span>	<span class="token expression"><span class="token number">128</span></span></span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// Maximum size of a complete pathname, including null</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXPATHLEN</span>	<span class="token expression"><span class="token number">1024</span></span></span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">// Number of (direct) block pointers in a File descriptor</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NDIRECT</span>		<span class="token expression"><span class="token number">10</span></span></span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NINDIRECT</span>	<span class="token expression"><span class="token punctuation">(</span>BY2BLK<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXFILESIZE</span>	<span class="token expression"><span class="token punctuation">(</span>NINDIRECT<span class="token operator">*</span>BY2BLK<span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BY2FILE</span>     <span class="token expression"><span class="token number">256</span></span></span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment">// File types</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FTYPE_REG</span>       <span class="token expression"><span class="token number">0</span>   </span><span class="token comment">// Regular file</span></span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FTYPE_DIR</span>       <span class="token expression"><span class="token number">1</span>   </span><span class="token comment">// Directory</span></span></pre></td></tr></table></figure><p>对关键的部分做解释， <code>BY2SECT</code> 表示 1 个扇区大小 512 字节， <code>SECT2BLK</code> 表示 1 个磁盘块是 8 个扇区， <code>DISKMAP</code> 和 <code>DISKMAX</code> 表示缓冲区地址范围为 0x10000000--0x3ffffffff，一个磁盘块大小 <code>BY2BLK</code> 等于一个页面大小（4KB），文件名最长为 <code>MAXNAMELEN</code> =128 个 <code>char</code> 字节， <code>File</code> 结构体用于索引，文件类型为文件 <code>FTYPE_REG</code> 或文件夹 <code>FTYPE_DIR</code></p><p>前面的宏主要用于内存分配，后面的宏主要用于用户操作</p><p>然后下面有超级块的结构体 <code>Super</code> ，也有向文件系统服务程序发出请求的包装结构体，也有文件描述结构体（FCB）</p><h3 id="thinking-58"><a class="anchor" href="#thinking-58">#</a> Thinking 5.8</h3><p>阅读 user/file.c，你会发现很多函数中都会将一个 <code>struct Fd*</code> 型的 指针转换为 <code>struct Filefd*</code> 型的指针，请解释为什么这样的转换可行。</p><p><strong>答案</strong></p><p>这一点跟面向对象编程语言中的<strong>多态</strong>和<strong>向下转型</strong>非常类似，因此我们不妨举一个 C++ 的例子</p><p><img data-src="http://c.biancheng.net/cpp/uploads/allimg/161108/1-16110Q53441I3.jpg" alt="img"></p><p>我们看到，虽然这里下面还有其它数据，但是我们的类型（这里是 <code>struct Fd*</code> ）的大小是已知的，因此我们不关心下面是什么，只关心到 <code>m_b</code> 指针指向的位置，这里就是这个结构体的结束，但是如果强制转换成 <code>struct Filefd*</code> 型，那么其大小更大，我们就会去解析获取下面的其它数据的内容</p><p><code>Filefd</code> 结构体的第一个元素就是 <code>Fd</code> 结构体，C 语言也能容忍强制转换操作，写代码的时候经常把一个 <code>void*</code> 指针变来变去的。因此直接执行这些代码没有任何问题</p><h3 id="thinking-59"><a class="anchor" href="#thinking-59">#</a> Thinking 5.9</h3><p>在 lab4 的实验中我们实现了极为重要的 <code>fork</code> 函数。那么 <code>fork</code> 前后的父子进程是否会共享文件描述符和定位指针呢？请在完成练习 5.8 和 5.9 的基础上编写一个程序进行验证。</p><p><strong>答案</strong></p><p>从 lab5-2 的课上测试来看，答案非常明显了，当然会共享文件描述符和定位指针。</p><p>课上测试的测试程序就可以作为编写的程序进行验证：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> r<span class="token punctuation">,</span> fdnum<span class="token punctuation">,</span> n<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">200</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>fdnum <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/newmotd"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fdnum<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"[child] buffer is \'%s\'\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fdnum<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token function">writef</span><span class="token punctuation">(</span><span class="token string">"[father] buffer is \'%s\'\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>father<span class="token punctuation">]</span> buffer is <span class="token string">'This '</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span>child<span class="token punctuation">]</span> buffer is <span class="token string">'is a '</span></pre></td></tr></table></figure><p>可以看出父子进程有相同的文件描述符，而且定位指针的位置也被传递给了子进程</p><h3 id="thinking-510"><a class="anchor" href="#thinking-510">#</a> Thinking 5.10</h3><p>请解释 <code>Fd</code> , <code>Filefd</code> , <code>Open</code> 结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。</p><p><strong>答案</strong></p><p>代码解读</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// file descriptor</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token punctuation">&#123;</span>					<span class="token comment">// 文件描述符，管理一个文件描述符（可以去指向打开文件），这个结构体是内存数据</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        u_int fd_dev_id<span class="token punctuation">;</span>	<span class="token comment">// 设备 id</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        u_int fd_offset<span class="token punctuation">;</span>	<span class="token comment">// 类似于文件定位指针的作用，标记随机读写的位置</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        u_int fd_omode<span class="token punctuation">;</span>		<span class="token comment">// 用户对该文件的操作权限和方式</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// file descriptor + file</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Filefd</span> <span class="token punctuation">&#123;</span>				<span class="token comment">// 文件描述符，描述指向已经打开的文件的文件描述符，比 Fd 多了 FCB 与 fileid，是内存数据</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">struct</span> <span class="token class-name">Fd</span> f_fd<span class="token punctuation">;</span>		<span class="token comment">// 文件描述符 记录打开的文件的部分信息</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        u_int f_fileid<span class="token punctuation">;</span>		<span class="token comment">// 文件系统为打开的文件的编号</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">struct</span> <span class="token class-name">File</span> f_file<span class="token punctuation">;</span>	<span class="token comment">// 文件的描述块</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> </pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// Open</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token comment">// 定义在 fs/serve.c 中，文件系统进程使用的描述一个打开文件的结构体</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Open</span> <span class="token punctuation">&#123;</span>				<span class="token comment">// 文件系统打开文件时，用来保存打开的文件信息，使用的时候会向 FIlefd 中传递数据</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>o_file<span class="token punctuation">;</span>	<span class="token comment">// 指向文件描述块的指针</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    u_int o_fileid<span class="token punctuation">;</span>			<span class="token comment">// 文件系统为打开的文件的编号，不能重复（系统同时最多打开 1024 个文件）</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">int</span> o_mode<span class="token punctuation">;</span>				<span class="token comment">// 用户对文件的操作权限</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">Filefd</span> <span class="token operator">*</span>o_ff<span class="token punctuation">;</span>	<span class="token comment">// 文件描述符指针</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>图示（Open 结构体保存在文件系统服务进程中，剩下两个是用户可见）</p><p><img data-src="https://img2022.cnblogs.com/blog/2323897/202202/2323897-20220224163100372-139409270.png" alt="img"></p><h3 id="thinking-511"><a class="anchor" href="#thinking-511">#</a> Thinking 5.11</h3><p>UML 时序图中有多种不同形式的箭头，请结合 UML 时序图的规范，解释这些不同箭头的差别，并思考我们的操作系统是如何实现对应类型的进程间通信的。</p><p><strong>答案</strong></p><blockquote><p>操作系统课程设计与 OO 作业绝赞联动中……</p></blockquote><p>言归正传，从 OO 课上（大雾），我们学到了：</p><ul><li><p><strong>同步消息</strong>，用黑三角箭头搭配黑实线表示。同步的意义：消息的发送者把进程控制传递给消息的接收者，然后<strong>暂停活动</strong>，<strong>等待</strong>消息接收者的回应消息。</p></li><li><p><strong>返回消息</strong>，用开三角箭头搭配黑色虚线表示。返回消息和同步消息结合使用，因为<strong>异步消息</strong>不进行等待，所以不需要知道返回值。</p></li></ul><p>当前 <code>serve</code> 执行到 <code>ipc_recv</code> ，通过 <code>syscall_ipc_recv</code> 进入使进程变成接收态 (NOT_RUNNABLE)，直到它收到消息，变成 RUNNABLE，才能够被调度，从 <code>ipc_recv</code> 的 <code>syscall_ipc_recv</code> 的后面的语句开始执行，并回到 <code>serve</code> ，所以这个服务中的文件系统进程不会死循环，空闲时会让出 CPU 让其余进程执行</p><p>从系统 IPC 的角度来看， <code>ipc_recv</code> 应当是同步消息，需要等待返回值，而 <code>ipc_send</code> 应当是异步消息，发送后无需关心返回值可以去做自己的事情</p><h3 id="thinking-512"><a class="anchor" href="#thinking-512">#</a> Thinking 5.12</h3><p>阅读 serv.c/serve 函数的代码，我们注意到函数中包含了一个死循环 for (;😉 {...}，为什么这段代码不会导致整个内核进入 panic 状态？</p><p><strong>答案</strong></p><p>该函数中有一步为 <code>req = ipc_recv(&amp;whom, REQVA, &amp;perm);</code> 它保证了在没有文件请求时，文件系统进程会一直等待下去，所以不会进入 <code>panic</code> 状态</p><p>事实上，文件系统进程需要永远运行下去，如果其退出了这个死循环，那绝对是致命的错误，这时内核才应该 <code>panic</code></p><h2 id="实验难点展示"><a class="anchor" href="#实验难点展示">#</a> 实验难点展示</h2><h3 id="难点1理解索引节点和数据块之间的关系"><a class="anchor" href="#难点1理解索引节点和数据块之间的关系">#</a> 难点 1：理解索引节点和数据块之间的关系</h3><p><img data-src="https://pic2.zhimg.com/80/v2-9d77e25913894df26b0374ceae25c605_720w.jpg" alt="img"></p><p><em>注：图片源自网络</em></p><p><img data-src="https://pdos.csail.mit.edu/6.828/2018/labs/lab5/file.png" alt="File structure"></p><blockquote><p>这是 MIT6.828 的 JOS 的图，我发现它们的代码跟我们的 MOS 很像诶，欸嘿嘿～</p></blockquote><p>这里理解上个人认为有以下难点：</p><ul><li>目录是文件，文件目录是目录，文件目录不等于目录文件</li><li>文件中二级指针块是从 10 开始编号的，一开始没有弄清楚这些细节，然后读代码的时候就非常费劲</li><li>指针指来指去很晕，自己在草稿纸上画一幅图会好一些</li></ul><h3 id="难点2文件系统服务进程的工作原理"><a class="anchor" href="#难点2文件系统服务进程的工作原理">#</a> 难点 2：文件系统服务进程的工作原理</h3><pre><code>      Regular env           FS env
   +---------------+   +---------------+
   |      read     |   |   file_read   |
   |   (lib/fd.c)  |   |   (fs/fs.c)   |
...|.......|.......|...|.......^.......|...............
   |       v       |   |       |       |    IPC 机制
   |  devfile_read |   |  serve_read   |
   |  (lib/file.c) |   |  (fs/serv.c)  |
   |       |       |   |       ^       |
   |       v       |   |       |       |
   |     fsipc     |   |     serve     |
   |  (lib/file.c) |   |  (fs/serv.c)  |
   |       |       |   |       ^       |
   |       v       |   |       |       |
   |   ipc_send    |   |   ipc_recv    |
   |       |       |   |       ^       |
   +-------|-------+   +-------|-------+
           |                   |
           +-------------------+
</code></pre><p>上图就是文件系统服务进程的工作原理</p><p>用户程序想要请求文件系统服务，需要通过进程间通信，向 <code>serv.c</code> 发送对应的请求结构体（定义在 <code>fs.h</code> ）中，然后 <code>serv.c</code> 调用 <code>fs.c</code> 中的函数完成服务</p><p>文件系统的设计是一个层次化的结构，底层操作硬件，逐级向上层提供封装好的接口，在第二部分编写 <code>fs.c</code> 中，就无需关心磁盘读写的细节，因为这些都由 <code>ide_read</code> 和 <code>ide_write</code> 封装好了，这种设计是非常精妙的</p><h2 id="体会和感想"><a class="anchor" href="#体会和感想">#</a> 体会和感想</h2><ul><li>lab5 整体难度相较于前两个降低了许多，从我通过了两次 Extra 就可见一斑</li><li>但是 lab5 的设计是非常精妙的，利用一个 **C/S（服务器部分和客户机部分）** 这种当今互联网应用的常用模式，巧妙的实现微内核中的文件系统服务</li><li>但是我还是有些担心，相较于宏内核系统，这样的文件服务效率是否会打折扣？</li><li>由于时间原因，可能没有非常细致的去阅读 lab5 的代码，但是下次一定补上，其中运用的包括底层向上层暴露封装好的接口（类似于面向对象中的继承和接口设计），包括上面提到的 C/S 架构，在今后必然有很大应用，值得我们去学习</li></ul><div class="tags"><a href="/tags/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="ic i-tag"></i> 北航操作系统</a> <a href="/tags/OS/" rel="tag"><i class="ic i-tag"></i> OS</a> <a href="/tags/Lab5/" rel="tag"><i class="ic i-tag"></i> Lab5</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-06-15 21:27:06" itemprop="dateModified" datetime="2022-06-15T21:27:06+08:00">2022-06-15</time> </span><span id="2022/06/15/BUAA-OS-2022/lab5/doc-lab5/" class="item leancloud_visitors" data-flag-title="BUAA-OS Lab5 实验总结" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="FL 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="FL 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="FL 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>FL <i class="ic i-at"><em>@</em></i>FlyingLandlord's Blog</li><li class="link"><strong>本文链接：</strong> <a href="http://flyinglandlord.github.io/2022/06/15/BUAA-OS-2022/lab5/doc-lab5/" title="BUAA-OS Lab5 实验总结">http://flyinglandlord.github.io/2022/06/15/BUAA-OS-2022/lab5/doc-lab5/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/04/29/BUAA-OS-2022/lab0-lab2/lab2-quiz/" itemprop="url" rel="prev" data-background-image="&#x2F;assets&#x2F;BangD.jpg" title="BUAA-OS Lab2上机"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 北航操作系统</span><h3>BUAA-OS Lab2上机</h3></a></div><div class="item right"><a href="/2022/06/15/BUAA-OS-2022/lab4/doc-lab4/" itemprop="url" rel="next" data-background-image="&#x2F;assets&#x2F;BangD.jpg" title="BUAA-OS Lab4实验总结"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 北航操作系统</span><h3>BUAA-OS Lab4实验总结</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#lab-5-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A"><span class="toc-number">1.</span> <span class="toc-text">lab-5 实验报告</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">实验思考题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-51"><span class="toc-number">1.1.1.</span> <span class="toc-text">Thinking 5.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-52"><span class="toc-number">1.1.2.</span> <span class="toc-text">Thinking 5.2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-53"><span class="toc-number">1.1.3.</span> <span class="toc-text">Thinking 5.3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-54"><span class="toc-number">1.1.4.</span> <span class="toc-text">Thinking 5.4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-55"><span class="toc-number">1.1.5.</span> <span class="toc-text">Thinking 5.5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-56"><span class="toc-number">1.1.6.</span> <span class="toc-text">Thinking 5.6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-57"><span class="toc-number">1.1.7.</span> <span class="toc-text">Thinking 5.7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-58"><span class="toc-number">1.1.8.</span> <span class="toc-text">Thinking 5.8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-59"><span class="toc-number">1.1.9.</span> <span class="toc-text">Thinking 5.9</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-510"><span class="toc-number">1.1.10.</span> <span class="toc-text">Thinking 5.10</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-511"><span class="toc-number">1.1.11.</span> <span class="toc-text">Thinking 5.11</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-512"><span class="toc-number">1.1.12.</span> <span class="toc-text">Thinking 5.12</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E9%9A%BE%E7%82%B9%E5%B1%95%E7%A4%BA"><span class="toc-number">1.2.</span> <span class="toc-text">实验难点展示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%BE%E7%82%B91%E7%90%86%E8%A7%A3%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E5%92%8C%E6%95%B0%E6%8D%AE%E5%9D%97%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.1.</span> <span class="toc-text">难点 1：理解索引节点和数据块之间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%BE%E7%82%B92%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.2.</span> <span class="toc-text">难点 2：文件系统服务进程的工作原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%93%E4%BC%9A%E5%92%8C%E6%84%9F%E6%83%B3"><span class="toc-number">1.3.</span> <span class="toc-text">体会和感想</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/04/22/BUAA-OS-2022/lab0-lab2/lab0-lab2_Summary/" rel="bookmark" title="lab0-lab2总结">lab0-lab2总结</a></li><li><a href="/2022/04/29/BUAA-OS-2022/lab0-lab2/lab2-quiz/" rel="bookmark" title="BUAA-OS Lab2上机">BUAA-OS Lab2上机</a></li><li><a href="/2022/04/29/BUAA-OS-2022/lab3/lab3-quiz/" rel="bookmark" title="BUAA-OS Lab3上机">BUAA-OS Lab3上机</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab0/" rel="bookmark" title="BUAA-OS Lab0实验总结">BUAA-OS Lab0实验总结</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab1/" rel="bookmark" title="BUAA-OS Lab1实验总结">BUAA-OS Lab1实验总结</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab2/" rel="bookmark" title="BUAA-OS Lab2实验总结">BUAA-OS Lab2实验总结</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab3/doc-lab3/" rel="bookmark" title="BUAA-OS Lab3实验总结">BUAA-OS Lab3实验总结</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab4/doc-lab4/" rel="bookmark" title="BUAA-OS Lab4实验总结">BUAA-OS Lab4实验总结</a></li><li class="active"><a href="/2022/06/15/BUAA-OS-2022/lab5/doc-lab5/" rel="bookmark" title="BUAA-OS Lab5实验总结">BUAA-OS Lab5实验总结</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="FL" data-src="/images/avatar.jpg"><p class="name" itemprop="name">FL</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">32</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">5</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">36</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZseWluZ2xhbmRsb3Jk" title="https:&#x2F;&#x2F;github.com&#x2F;flyinglandlord"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjI2NDUzNzcxNjFAcXEuY29t" title="mailto:2645377161@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/04/29/BUAA-OS-2022/lab0-lab2/lab2-quiz/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/06/15/BUAA-OS-2022/lab4/doc-lab4/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/09/15/BUAA-CO-2021/Pre/Logisim%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/" title="Logisim斐波那契电路">Logisim斐波那契电路</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/" title="分类于 二进制杂谈">二进制杂谈</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/Theme-Shoka-Documentation/" title="分类于 Theme Shoka Documentation">Theme Shoka Documentation</a></div><span><a href="/2020/08/13/%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/" title="主题特殊功能测试">主题特殊功能测试</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="分类于 北航操作系统">北航操作系统</a></div><span><a href="/2022/04/29/BUAA-OS-2022/lab3/lab3-quiz/" title="BUAA-OS Lab3上机">BUAA-OS Lab3上机</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="分类于 北航操作系统">北航操作系统</a></div><span><a href="/2022/06/15/BUAA-OS-2022/lab3/doc-lab3/" title="BUAA-OS Lab3实验总结">BUAA-OS Lab3实验总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/12/29/BUAA-CO-2021/P8/P8%E8%AF%BE%E4%B8%8A&%E8%AF%BE%E4%B8%8B/" title="P8课下&amp;课上总结">P8课下&课上总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/12/01/BUAA-CO-2021/P5/P5%E8%AF%BE%E4%B8%8B/" title="P5课下学习—流水线CPU设计(1)">P5课下学习—流水线CPU设计(1)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/12/02/BUAA-CO-2021/P5/P5%E8%AF%BE%E4%B8%8A1&2/" title="P5课上测试1&amp;2">P5课上测试1&2</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/10/13/BUAA-CO-2021/Pre/Pre%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95/" title="Pre课上测试游记">Pre课上测试游记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/11/03/BUAA-CO-2021/P2/P2%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95%E6%B8%B8%E8%AE%B0/" title="P2课上测试游记">P2课上测试游记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/10/13/BUAA-CO-2021/Pre/Logisim%E5%A4%8D%E4%B9%A0/" title="Logisim Pre考前复习">Logisim Pre考前复习</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">FL @ Test Blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/06/15/BUAA-OS-2022/lab5/doc-lab5/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>