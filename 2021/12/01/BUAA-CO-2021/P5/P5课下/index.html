<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="FlyingLandlord's Blog" href="http://flyinglandlord.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="FlyingLandlord's Blog" href="http://flyinglandlord.github.io/atom.xml"><link rel="alternate" type="application/json" title="FlyingLandlord's Blog" href="http://flyinglandlord.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="北航计算机组成原理,Verilog,MIPS,流水线CPU,P5课下"><link rel="canonical" href="http://flyinglandlord.github.io/2021/12/01/BUAA-CO-2021/P5/P5%E8%AF%BE%E4%B8%8B/"><title>P5 课下学习 — 流水线 CPU 设计 (1) - 北航计算机组成原理 | Test Blog = FlyingLandlord's Blog</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">P5 课下学习 — 流水线 CPU 设计 (1)</h1><div class="meta"><span class="item" title="创建时间：2021-12-01 23:10:12"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-12-01T23:10:12+08:00">2021-12-01</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Test Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://api.yimian.xyz/img?type=wallpaper&size=1920x1080?661"></li><li class="item" data-background-image="https://api.yimian.xyz/img?type=wallpaper&size=1920x1080?917603"></li><li class="item" data-background-image="https://api.yimian.xyz/img?type=wallpaper&size=1920x1080?721315"></li><li class="item" data-background-image="https://api.yimian.xyz/img?type=wallpaper&size=1920x1080?523728"></li><li class="item" data-background-image="https://api.yimian.xyz/img?type=wallpaper&size=1920x1080?143278"></li><li class="item" data-background-image="https://api.yimian.xyz/img?type=wallpaper&size=1920x1080?804313"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="item" rel="index" title="分类于 北航计算机组成原理"><span itemprop="name">北航计算机组成原理</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://flyinglandlord.github.io/2021/12/01/BUAA-CO-2021/P5/P5%E8%AF%BE%E4%B8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="FL"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="FlyingLandlord's Blog"></span><div class="body md" itemprop="articleBody"><h1 id="p5课下项目流水线cpu设计1"><a class="anchor" href="#p5课下项目流水线cpu设计1">#</a> P5 课下项目：流水线 CPU 设计（1）</h1><div class="note warning"><p>阅读本文或许可以给您完成 P5 课下任务提供些许帮助，但是绝对不能让你完全搭出 P5<br>这篇文章只是讲了我个人对于流水线的一些理解，剩下的可以参考其他大佬的代码学习</p></div><p><span class="spoiler" title="你知道得太多了">如果我也能发 D-Mail 的话，我要告诉一周前的自己 bonall 指令是无条件链接，然后世界线就会切换到我上周就过了 P5 的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05278em">β</span></span></span></span> 世界线了</span><br></p><div class="media-container"><div class="player" data-type="audio" data-src='[{"title":"命运石之门","list":["https://music.163.com/#/song?id=26584163","https://music.163.com/#/song?id=442562849"]}]'></div></div><p></p><h2 id="总体设计概述"><a class="anchor" href="#总体设计概述">#</a> 总体设计概述</h2><p>要求实现的指令集为 <code>MIPS-lite2</code> ，即<strong> addu，subu，ori，lw，sw，beq， jal，jr，lui，nop</strong></p><p>整体结构如下图所示</p><p><img data-src="https://i.loli.net/2021/12/01/yz7I3gYW2btBwpl.png" alt="image-20211121213133568"></p><h3 id="命名规范"><a class="anchor" href="#命名规范">#</a> 命名规范</h3><p>由于到了 P5 流水线，导线和元件实在太多了，所以用特定的名称约定便于编码：</p><ul><li>对于元件的文件命名，均为 <code>流水线层级_元件英文简称</code> ，例如 <code>D_GRF.v</code> ， <code>E_ALU.v</code> 等，实例化时命名为 <code>_小写英文名</code> ，例如 <code>_alu</code> ， <code>_grf</code> 等</li><li>对于流水线寄存器文件命名为 <code>两边的流水线层级_REG</code> ，例如 <code>FD_REG.v</code> ， <code>DE_REG.v</code> ，实例化时命名为 <code>_小写英文名</code> ，例如 <code>_fd_reg</code></li><li>每一级的控制信号和临时的 <code>wire</code> 均以本级的名称开头，如 <code>E_ALUOp</code> ， <code>M_DMOp</code> 等</li><li>在流水线中参与流水的信息遵从以下约定（以 D 级为例）<ul><li><code>PC</code> 和 <code>Instr</code> 命名以流水线层级开头，如 <code>D_PC</code> ， <code>D_Instr</code></li><li>寄存器地址分别为 <code>D_rs_addr</code> ， <code>D_rt_addr</code> ，读出数据为 <code>D_rs_data</code> ， <code>D_rt_data</code></li><li>转发得到的寄存器数据（直接读取也视为一种转发）记作 <code>D_FWD_rs_data</code> ， <code>D_FWD_rt_data</code></li><li>即将写入的寄存器地址为 <code>E_GRFA3</code> ，即将写入的数据记作 <code>E_GRFWD</code> ，选择信号为 <code>E_GRFWDSel</code></li></ul></li></ul><h3 id="一些搭建要点"><a class="anchor" href="#一些搭建要点">#</a> 一些搭建要点</h3><p>首先是译码，我参考了一些大佬的架构后，采用了分布式译码，CTRL 在每一级都会进行译码，即只写一个 <code>control.v</code> 模块，然后实例化四次，每一次都根据 <code>Instr</code> 信号译码得到当前流水线层级需要的控制信号和别的转发需要的乱七八糟的东西（转发后面再讲）</p><h4 id="d级decode译码"><a class="anchor" href="#d级decode译码">#</a> D 级 (Decode / 译码)</h4><p><img data-src="https://i.loli.net/2021/12/01/TdyhbZenfKwqtMp.png" alt="image-20211122222901038"></p><h4 id="e级execute执行"><a class="anchor" href="#e级execute执行">#</a> E 级 (Execute / 执行)</h4><p><img data-src="https://i.loli.net/2021/12/01/KBZGJ1EkvoHaq6c.png" alt="image-20211122222923422"></p><h4 id="m级memory储存"><a class="anchor" href="#m级memory储存">#</a> M 级 (Memory / 储存)</h4><p><img data-src="https://i.loli.net/2021/12/01/KRSwim4FdTtAQBs.png" alt="image-20211122223011487"></p><h4 id="w级write回写"><a class="anchor" href="#w级write回写">#</a> W 级 (Write / 回写)</h4><p><img data-src="https://i.loli.net/2021/12/01/oAgZ6OQNuEa7ix1.png" alt="image-20211122223031822"></p><p>可以确定的是，我们的 <code>Instr</code> 和 <code>PC</code> 信号必须跟着流水线一起传递， <code>Instr</code> 是译码需要， <code>PC</code> 是评测机要求输出 <code>PC</code> 的值</p><p>流水线复杂的一点在于，它有 FDEMW 五个层级，每一个层级都有很多信号需要处理，但是每一级都只是组合逻辑（不考虑 P6 的乘除槽），<strong>因此我们首先要搞清楚的是每一级都需要什么数据，每一级又向后输出什么数据</strong>，然后只需要考虑每个层级里面的逻辑就行了</p><p>下面将按照流水线层级逐一分析各个单元</p><h4 id="f级fetch取指令"><a class="anchor" href="#f级fetch取指令">#</a> F 级 (Fetch / 取指令)</h4><ul><li>本级的输入是来自 D 级的 <code>NPC</code></li><li>本级的输出是 <code>F_PC</code> 和 <code>F_Instr</code> ，两者需要参与流水线流水</li></ul><h5 id="ifu取指单元"><a class="anchor" href="#ifu取指单元">#</a> IFU（取指单元）</h5><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>NPC[31:0]</td><td>输入</td><td>待写入 PC 的指令地址</td></tr><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>PC_WrEn</td><td>输入</td><td>PC 的写使能</td></tr><tr><td>PC</td><td>输出</td><td>当前指令地址</td></tr><tr><td>Instr[31:0]</td><td>输出</td><td>32 位的指令值</td></tr></tbody></table><h4 id="d级decode译码-2"><a class="anchor" href="#d级decode译码-2">#</a> D 级 (Decode / 译码)</h4><ul><li>本级的输入是来自 F 级的 <code>PC</code> 和 <code>Instr</code></li><li>输出是 <code>D_rs_data</code> （从 GPR 里面读的 rs 的值）， <code>D_rt_data</code> （从 GPR 里面读的 rt 的值）， <code>D_ext32</code> （16 位立即数扩展后的值）， <code>D_PC</code> 和 <code>D_Instr</code> ，还有输出到 F 级的 <code>NPC</code></li><li>其他的信号像 D_rs_addr 都可以从 control 中译码得到</li></ul><h5 id="fd_regfd级流水线寄存器"><a class="anchor" href="#fd_regfd级流水线寄存器">#</a> FD_REG（F/D 级流水线寄存器）</h5><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>flush</td><td>输入</td><td>寄存器刷新信号（阻塞时使用）</td></tr><tr><td>F_PC</td><td>输入</td><td>F 级 PC 的指令地址</td></tr><tr><td>F_Instr[31:0]</td><td>输入</td><td>时钟信号</td></tr><tr><td>D_PC</td><td>输出</td><td>D 级 PC 的指令地址</td></tr><tr><td>D_Instr[31:0]</td><td>输出</td><td>32 位的指令值</td></tr></tbody></table><h5 id="d_grf寄存器堆"><a class="anchor" href="#d_grf寄存器堆">#</a> D_GRF（寄存器堆）</h5><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A1[4:0]</td><td>输入</td><td>5 位地址输入信号，将其储存的数据读出到 RD1</td></tr><tr><td>A2[4:0]</td><td>输入</td><td>5 位地址输入信号，将其储存的数据读出到 RD2</td></tr><tr><td>A3[4:0]</td><td>输入</td><td>5 位地址输入信号，将其作为写入数据的目标寄存器</td></tr><tr><td>RD1[31:0]</td><td>输出</td><td>输出 A1 指定的寄存器中的 32 位数据</td></tr><tr><td>RD2[31:0]</td><td>输出</td><td>输出 A2 指定的寄存器中的 32 位数据</td></tr><tr><td>WD[31:0]</td><td>输入</td><td>32 位数据输入信号</td></tr><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>异步复位信号，将 32 个寄存器中的数据清零；1：复位；0：无效</td></tr></tbody></table><ul><li>这次删去了 <code>GRFWrEn</code> 写使能信号，因为如果我们不写寄存器，可以把 <code>GRFA3</code> 设为 0，就相当于不写寄存器了</li></ul><p><strong>1. <code>D_GRFA3</code></strong></p><p>直接给出待写入寄存器的地址，弃用了在 P4 中利用 <code>GRFA3Sel</code> 进行选择的设计，这是因为 P5 采用分布式译码，每一级都需要 <code>GRFA3</code> 的信息，因此在 <code>CTRL</code> 里面直接集成了</p><p><strong>2. <code>D_GRFWDSel</code></strong></p><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>WDSel_dmrd</code></td><td>选择写入寄存器的数据来自 DM</td></tr><tr><td><code>WDSel_aluans</code></td><td>选择写入寄存器的数据来自 ALU 运算结果</td></tr><tr><td><code>WDSel_pc8</code></td><td>选择写入寄存器的数据为<strong>当前流水线层级中的 PC+8</strong></td></tr></tbody></table><h5 id="d_ext位扩展"><a class="anchor" href="#d_ext位扩展">#</a> D_EXT（位扩展）</h5><p>将 16 位二进制数进行零扩展或符号扩展到 32 位</p><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>EXT_unsign</code></td><td>零扩展</td></tr><tr><td><code>EXT_sign</code></td><td>符号扩展</td></tr></tbody></table><h5 id="d_cmp比较器"><a class="anchor" href="#d_cmp比较器">#</a> D_CMP（比较器）</h5><p>把原来 ALU 中比较值是否相等的运算移到了 CMP 里面，去指导 <code>beq</code> 这一类型的指令是否跳转</p><p>控制信号目前只有 <code>CMP_beq</code> ，未来可以扩展</p><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>rs[31:0]</td><td>输入</td><td><strong>处理完转发后</strong> <code>$rs</code> 寄存器的值</td></tr><tr><td>rt[31:0]</td><td>输入</td><td><strong>处理完转发后</strong> <code>$rt</code> 寄存器的值</td></tr><tr><td>CMPOp[2:0]</td><td>输入</td><td>控制信号</td></tr><tr><td>b_jump</td><td>输出</td><td>指示是否跳转，输入 <code>NPC</code> ，未来可以添加 <code>bltzal</code> 指令</td></tr></tbody></table><h5 id="d_npc次地址计算单元"><a class="anchor" href="#d_npc次地址计算单元">#</a> D_NPC（次地址计算单元）</h5><p>把 <code>beq</code> 是否执行的判断交给了 <code>CMP</code> ，直接根据输入信号 <code>jump</code> 判断是否跳转</p><p>其实 <code>NPC</code> 横跨了 F 级和 D 级两级，因为同时会输入 <code>F_PC</code> 和 <code>D_PC</code> ，前者正常跳转 <code>F_PC+4</code> 用，后者则用于流水 <code>PC</code> 值，后面转发 <code>PC+8</code> 的时候用</p><p>这次我们弃用了 P4 中直接输出 <code>PC+4</code> 的设计，转而让 <code>PC</code> 信号参与流水，在需要转发时计算 <code>PC+8</code></p><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>F_PC[31:0]</td><td>输入</td><td>32 位输入当前 F 级地址</td></tr><tr><td>D_PC[31:0]</td><td>输入</td><td>32 位输入当前 D 级地址</td></tr><tr><td>b_jump</td><td>输入</td><td>指示 b 类型指令是否跳转</td></tr><tr><td>NPCOp[1:0]</td><td>输入</td><td>控制信号</td></tr><tr><td>RSS[31:0]</td><td>输入</td><td><strong>处理完转发后</strong> <code>$rs</code> 寄存器保存的 32 位地址</td></tr><tr><td>NPC[31:0]</td><td>输出</td><td>32 位输出次地址</td></tr></tbody></table><h5 id="控制信号说明"><a class="anchor" href="#控制信号说明">#</a> 控制信号说明</h5><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>NPC_pc4</code></td><td><code>NPC=PC+4</code></td></tr><tr><td><code>NPC_b</code></td><td>执行 <code>beq</code> 等 b 类指令</td></tr><tr><td><code>NPC_j_jal</code></td><td>执行 <code>j</code> ， <code>jal</code> 指令</td></tr><tr><td><code>NPC_jalr_jr</code></td><td>执行 <code>jalr</code> ， <code>jr</code> 指令</td></tr></tbody></table><h4 id="e级execute执行-2"><a class="anchor" href="#e级execute执行-2">#</a> E 级 (Execute / 执行)</h4><ul><li>输入 <code>D_PC,D_Instr,D_ext32</code> ，此外上一级的 <code>$rs</code> 和 <code>$rt</code> 的值也要参与流水，即 <code>D_FWD_rs,D_FWD_rt</code> 需要参与流水，<strong>这是由于指令序列 <code>sw, nop, addu</code> 的存在， <code>sw</code> 在 M 级需要使用 <code>$rt</code> 的数据，但是在 E 级不会再进行转发（因为在 D 级已经转发过了），因此需要让正确的 <code>$rt</code> 值参与流水</strong></li><li>输出 <code>E_PC,E_Instr,E_ext32,E_rs_data,E_rt_data</code> ， <code>ALU</code> 需要这些信息</li></ul><h5 id="de_regde级流水线寄存器"><a class="anchor" href="#de_regde级流水线寄存器">#</a> DE_REG（D/E 级流水线寄存器）</h5><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>flush</td><td>输入</td><td>寄存器刷新信号（阻塞时使用）</td></tr><tr><td>D_PC[31:0]</td><td>输入</td><td>D 级 PC 的指令地址</td></tr><tr><td>D_Instr[31:0]</td><td>输入</td><td>32 位的指令值</td></tr><tr><td>D_ext32[31:0]</td><td>输出</td><td>16 位立即数经 <code>EXT</code> 扩展的结果</td></tr><tr><td>D_rs_data[31:0]</td><td>输出</td><td>32 位的寄存器数据</td></tr><tr><td>D_rt_data[31:0]</td><td>输出</td><td>32 位的寄存器数据</td></tr><tr><td>E_PC[31:0]</td><td>输入</td><td>E 级 PC 的指令地址</td></tr><tr><td>E_Instr[31:0]</td><td>输入</td><td>32 位的指令值</td></tr><tr><td>E_ext32[31:0]</td><td>输出</td><td>16 位立即数经 <code>EXT</code> 扩展的结果</td></tr><tr><td>E_rs_data[31:0]</td><td>输出</td><td>32 位的寄存器数据</td></tr><tr><td>E_rt_data[31:0]</td><td>输出</td><td>32 位的寄存器数据</td></tr></tbody></table><h5 id="e_alu算术逻辑单元"><a class="anchor" href="#e_alu算术逻辑单元">#</a> E_ALU（算术逻辑单元）</h5><ul><li><strong>相比于 P4，ALU 做了很大的变动</strong>，添加了 <code>ALUASel</code> 信号选择 A 运算数的来源，这是为了便于扩展 <code>sll</code> 和 <code>sllv</code> 类指令的原因取消了 <code>shamt</code> 信号， <code>shamt</code> 信号从 <code>ALUBSel</code> 中选择进入 <code>ALU</code> 中</li></ul><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>输入</td><td>32 位输入运算数 A</td></tr><tr><td>B[31:0]</td><td>输入</td><td>32 位输入运算数 B</td></tr><tr><td>ALUOp[4:0]</td><td>输入</td><td>控制信号</td></tr><tr><td>C[31:0]</td><td>输出</td><td>32 位输出运算结果</td></tr></tbody></table><p><strong>1. ALUOp</strong></p><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>ALU_add</code></td><td>执行加法运算</td></tr><tr><td><code>ALU_sub</code></td><td>执行减法运算</td></tr><tr><td><code>ALU_or</code></td><td>执行逻辑或运算</td></tr><tr><td><code>ALU_lui</code></td><td>执行 <code>lui</code> 指令</td></tr></tbody></table><p><strong>2. ALUASel</strong></p><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>ASel_rt</code></td><td>对于 <code>sll</code> 和 <code>sllv</code> 等移位指令，选择 <code>$rt</code> 的值</td></tr><tr><td><code>ASel_rs</code></td><td>对于其他大部分运算指令，采用 <code>$rs</code> 的值</td></tr></tbody></table><p><strong>3. ALUBSel</strong></p><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td><code>BSel_rt</code></td><td>选择<strong>处理完转发后</strong> <code>$rt</code> 寄存器中的值进行运算</td></tr><tr><td><code>BSel_imm</code></td><td>选择立即数进行运算</td></tr><tr><td><code>BSel_shamt</code></td><td>使用 <code>&#123;27'b0, E_ALUshamt&#125;</code> 得到 32 为扩展移位数</td></tr><tr><td><code>BSel_rs</code></td><td>考虑到 <code>sllv</code> 指令要求可变的位移数，这里可以选择 <code>&#123;27'b0, E_FWD_rs_data[4:0]&#125;</code> ，即 <code>$rs</code> 寄存器中的数据作为移位数</td></tr></tbody></table><h4 id="m级memory储存-2"><a class="anchor" href="#m级memory储存-2">#</a> M 级 (Memory / 储存)</h4><ul><li>输入 <code>E_PC,E_Instr</code> ，此外 <code>E_ALUAns,E_ext32</code> 也需要输入，<strong>这是因为 <code>ALUAns</code> 是待写入或读取的内存地址</strong>，<strong>另外，上一级的 rt 值需要进入 M 级</strong>，因此还需要输入 <code>E_FWD_rt</code> ，<strong>这是因为 <code>sw</code> 指令会向内存中写入 <code>$rt</code> 的数据</strong></li><li>输出 <code>M_PC,M_Instr,M_ALUAns,M_DMRD</code></li></ul><h5 id="em_regem级流水线寄存器"><a class="anchor" href="#em_regem级流水线寄存器">#</a> EM_REG（E/M 级流水线寄存器）</h5><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>flush</td><td>输入</td><td>寄存器刷新信号（阻塞时使用）</td></tr><tr><td>E_PC[31:0]</td><td>输入</td><td>E 级 PC 的指令地址</td></tr><tr><td>E_Instr[31:0]</td><td>输入</td><td>32 位的指令值</td></tr><tr><td>E_ext32[31:0]</td><td>输入</td><td>16 位立即数经 <code>EXT</code> 扩展的结果</td></tr><tr><td>E_rt_data[31:0]</td><td>输入</td><td>32 位的寄存器数据</td></tr><tr><td>E_ALUAns[31:0]</td><td>输入</td><td>32 位的 ALU 运算结果</td></tr><tr><td>M_PC[31:0]</td><td>输出</td><td>M 级 PC 的指令地址</td></tr><tr><td>M_Instr[31:0]</td><td>输出</td><td>32 位的指令值</td></tr><tr><td>M_ext32[31:0]</td><td>输出</td><td>16 位立即数经 <code>EXT</code> 扩展的结果</td></tr><tr><td>M_ALUAns[31:0]</td><td>输出</td><td>32 位的 ALU 运算结果</td></tr><tr><td>M_rt_data[31:0]</td><td>输出</td><td>32 位的寄存器数据</td></tr></tbody></table><h5 id="m_dm数据储存器"><a class="anchor" href="#m_dm数据储存器">#</a> M_DM（数据储存器）</h5><ul><li>与 P4 基本相同</li></ul><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>Addr[31:0]</td><td>输入</td><td>待操作的内存地址</td></tr><tr><td>WD[31:0]</td><td>输入</td><td>待写入内存的值</td></tr><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>异步复位信号</td></tr><tr><td>DMWrEn</td><td>输入</td><td>写使能信号；1：写入有效；0：写入无效</td></tr><tr><td>DMOp[2:0]</td><td>输入</td><td>控制信号</td></tr><tr><td>RD[31:0]</td><td>输出</td><td>输入地址指向的内存中储存的值</td></tr></tbody><tbody><tr><td>控制信号值</td><td>功能</td></tr><tr><td>----------</td><td>--------------------------------------------</td></tr><tr><td><code>DM_w</code></td><td>对应 <code>lw</code> 和 <code>sw</code> 指令，写入或读取整个字</td></tr><tr><td><code>DM_h</code></td><td>（保留）对应 <code>lh</code> 和 <code>sh</code> 指令，写入或读取半字</td></tr><tr><td><code>DM_b</code></td><td>（保留）对应 <code>lb</code> 和 <code>sb</code> 指令，写入或读取整个字</td></tr><tr><td><code>DM_hu</code></td><td>（保留）对应 <code>lhu</code> 指令</td></tr><tr><td><code>DM_bu</code></td><td>（保留）对应 <code>lbu</code> 指令</td></tr></tbody></table><h4 id="w级write回写-2"><a class="anchor" href="#w级write回写-2">#</a> W 级 (Write / 回写)</h4><ul><li><strong>W 级事实上与 D 级重合了，但是仍然需要处理向 E,M 级的转发</strong></li></ul><h5 id="mw_regmw级流水线寄存器"><a class="anchor" href="#mw_regmw级流水线寄存器">#</a> MW_REG（M/W 级流水线寄存器）</h5><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>clk</td><td>输入</td><td>时钟信号</td></tr><tr><td>reset</td><td>输入</td><td>同步复位信号</td></tr><tr><td>flush</td><td>输入</td><td>寄存器刷新信号（阻塞时使用）</td></tr><tr><td>M_PC[31:0]</td><td>输入</td><td>M 级 PC 的指令地址</td></tr><tr><td>M_Instr[31:0]</td><td>输入</td><td>32 位的指令值</td></tr><tr><td>M_DMRD[31:0]</td><td>输入</td><td>从内存中读取的值</td></tr><tr><td>M_ALUAns[31:0]</td><td>输入</td><td>32 位的 ALU 运算结果</td></tr><tr><td>W_PC[31:0]</td><td>输出</td><td>W 级 PC 的指令地址</td></tr><tr><td>W_Instr[31:0]</td><td>输出</td><td>32 位的指令值</td></tr><tr><td>W_DMRD[31:0]</td><td>输出</td><td>从内存中读取的值</td></tr><tr><td>W_ALUAns[31:0]</td><td>输出</td><td>32 位的 ALU 运算结果</td></tr></tbody></table><p>其实我们发现，每一级的流水线寄存器是承上启下的作用，搞清楚流水线寄存器怎么写，就明白了每一级需要输入什么数据，又需要输出什么数据，每一级内部的东西跟 P4 比其实没有啥变化</p><p>变化最大的需要关注 <code>NPC</code> ，它处于 D 级，但同时接受 F 和 D 级的输入，而且输出 NPC 是直接回写的 F 级的，比较麻烦</p><p>D 级的元件最多，非常复杂，可以尝试把他们分成运算区（EXT, GPR）、跳转区（CMP, NPC）考虑，这样会容易一点</p><h2 id="冲突处理方法"><a class="anchor" href="#冲突处理方法">#</a> 冲突处理方法</h2><h3 id="转发"><a class="anchor" href="#转发">#</a> 转发</h3><p>为什么要转发？简单讲就是如果我用的寄存器里面的值，现在还没有写到寄存器里面，<strong>但是已经被算出来了</strong>，这个时候就需要算出来的那条指令告诉我他算出来了啥，我就不用寄存器里面的值了，这就是转发</p><p>对于转发，直接采用 AT 法 + 暴力转发，首先要搞明白转发到哪，转发什么</p><p>对于每一个流水线层级，我们要能够确定当前这一级正在执行的指令要写什么数据，向哪里写，因此就要维护 <code>GRFWD</code> （解决转发啥）和 <code>GRFA3</code> （解决转发到哪）这两个值，我们转发需要去关注的也就是这两个数据，<strong>这些信号都可以从 Control 里面译码读出来</strong></p><p>简单来说就是，我们需要在每一级都知道本级需要从哪读数据，要写到哪，要写啥，<strong>现在</strong>不知道没事，总之<strong>在这条指令从流水线消失之前</strong>，我们肯定知道，并且可以根据这些再经过判断做转发</p><p>需要用转发数据的地方参考下面这张图的红色部分，图里面的 MDU 是乘除槽，P5 不用做（图片来源：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNvZWtqYW4uY24v">Coekjan</span>）</p><p><img data-src="https://blog.coekjan.cn/img/P-CPU-DP-3.svg" alt="img"></p><p>在每一个需要用转发数据的地方，我们去比较要用的数据的 GPR 地址和前面正在维护的要写的 GRFA3 的地址，如果相同，那就意味着我们要写的寄存器已经被用了，但是这时前面获得的值显然是错误的，这时候直接转发过去就好了</p><p>这里还要考虑优先级的问题，越靠近这条指令，得到的数据就越新，我们就越倾向于<strong>优先</strong>使用这些数据</p><p>利用 AT 法，<strong>如果不阻塞就意味着一定能够在使用该寄存器的值之前获得正确的值</strong>，这就是 T 的作用，对于每一条指令，我们都维护他需要用 rt 和 rs 两个寄存器的时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>u</mi><mi>s</mi><msub><mi>e</mi><mrow><mi>r</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Tuse_{rt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.2805559999999999em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.02778em">r</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>u</mi><mi>s</mi><msub><mi>e</mi><mrow><mi>r</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Tuse_{rs}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.02778em">r</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，即再经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>u</mi><mi>s</mi><msub><mi>e</mi><mrow><mi>r</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Tuse_{rs}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.02778em">r</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 个周期之后，我们需要用 rs 寄存器里的值；同时我们也去维护指令（如果要写入寄存器的话），啥时候值才会被算出来，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>n</mi><mi>e</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">Tnew</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.02691em">w</span></span></span></span> 个周期后我们才能算出正确的 <code>GRFWD</code> ，才能做转发</p><p>如果我们要用的时候，这个正确的值还没有算出来，那肯定不行，这时候我们就阻塞，如果能算出来，那么之前转发的错误的值不用去管它，<strong>最后总能得到一个正确的值去覆盖原先错误的值</strong></p><p>如果我们还不知道要写的值是啥，那这个时候 <code>GRFA3</code> 就给正确的地址， <code>GRFWD</code> 就给 <code>32'bz</code> ，这时还不能做转发，但是如果写的阻塞模块正确，这个值就不可能被转发，因为这种情况如果出现就已经被阻塞在 D 级了</p><p>如果我们连要写哪个地址都不知道（课上加的指令可能会是这种情况），那就直接在 D 级暴力阻塞，肯定也不会被执行，从而得到转发的数据</p><p>转发逻辑的关键代码如下：</p><p><strong>W-D 级转发在寄存器内部实现，寄存器内部转发一定要做</strong></p><p><img data-src="https://i.loli.net/2021/12/01/2GcaxdOfyhnI8PJ.png" alt="image-20211122223250854"></p><p><img data-src="https://i.loli.net/2021/12/01/hVof3pslNnMZjyW.png" alt="image-20211122223302565"></p><p><img data-src="https://i.loli.net/2021/12/01/2kP3B6amc5dXZIu.png" alt="image-20211122223312221"></p><h3 id="阻塞"><a class="anchor" href="#阻塞">#</a> 阻塞</h3><p>对于阻塞的处理，直接采用教程中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Tuse</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>n</mi><mi>e</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">Tnew</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.02691em">w</span></span></span></span> 进行判断的方法，设计一个 <code>stall_CTRL</code> 模块，专门负责处理阻塞时流水线寄存器的 <code>flush</code> 和 <code>WrEn</code> 信号就行</p><p><strong>只可能在 D 级进行阻塞</strong>，阻塞控制器接受 D，E，M 级的指令输入，处理分析指令类别，并给他们赋上不同的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Tuse</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>n</mi><mi>e</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">Tnew</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.02691em">w</span></span></span></span> 的值，然后用组合逻辑判断，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>u</mi><mi>s</mi><mi>e</mi><mo>&lt;</mo><mi>T</mi><mi>n</mi><mi>e</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">Tuse &lt; Tnew</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.72243em;vertical-align:-.0391em"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.02691em">w</span></span></span></span> 就直接阻塞 D 级，直到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>u</mi><mi>s</mi><mi>e</mi><mo>=</mo><mi>T</mi><mi>n</mi><mi>e</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">Tuse=Tnew</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.02691em">w</span></span></span></span> 时再继续执行</p><p><img data-src="https://i.loli.net/2021/12/01/3jy5diXZfNY1orT.png" alt="image-20211122223559953"></p><p><strong>其实上面说这么多也未必讲的明白，直接去<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29t"> Github</span> 参考一些学长的代码，然后自己造几组数据看看波形，到底指令是怎么流水的，转发了什么，啥时候阻塞，然后自己再搭，就大部分都清楚了</strong></p><h2 id="思考题参考答案"><a class="anchor" href="#思考题参考答案">#</a> 思考题参考答案</h2><h3 id="流水线冒险"><a class="anchor" href="#流水线冒险">#</a> 流水线冒险</h3><ol><li>在采用本节所述的控制冒险处理方式下，PC 的值应当如何被更新？请从数据通路和控制信号两方面进行说明。</li></ol><p><img data-src="https://i.loli.net/2021/12/01/GF8trL2yg6PZaMf.png" alt="image-20211123163528500"></p><p>如图所示，直接利用 <code>NPCOp</code> 控制信号维护下一周期的 PC 值，其中有四种可能性即 <code>branch</code> 型， <code>jr/jalr</code> 型， <code>j/jal</code> 型和 <code>PC+4</code> 型</p><ol start="2"><li>对于 jal 等需要将指令地址写入寄存器的指令，为什么需要回写 PC+8 ？</li></ol><p>需要考虑延迟槽，在跳转指令后面后面有 nop 或者一条数据无关的指令。</p><h3 id="数据冒险的分析"><a class="anchor" href="#数据冒险的分析">#</a> 数据冒险的分析</h3><p>为什么所有的供给者都是存储了上一级传来的各种数据的<strong>流水级寄存器</strong>，而不是由 ALU 或者 DM 等部件来提供数据？</p><p>如果从非流水线寄存器部件转发，那么某一级的总延迟就会增加，从而根据木桶效应，时钟周期就会增加，总效率反而降低，得不偿失。</p><h3 id="at-法处理流水线数据冒险"><a class="anchor" href="#at-法处理流水线数据冒险">#</a> AT 法处理流水线数据冒险</h3><ol><li><p>“转发（旁路）机制的构造” 中的 Thinking 1-4；</p><ol><li><p>如果不采用已经转发过的数据，而采用上一级中的原始数据，会出现怎样的问题？试列举指令序列说明这个问题。</p><p>计算过程或存储过程中会用到还未更改过的寄存器值，从而出错。例如：</p><pre><code class="language-assembly">ori $1, $0, 1
nop
nop
nop
nop
lw $1, 0($0)
nop
sw $1, 4($0)
</code></pre><p><strong>这时，当指令 <code>sw</code> 达到 M 级时， <code>lw</code> 已经执行完毕，不会转发</strong>，但是我们有没有保留 E 级已经转发过的数据，这样 <code>sw</code> 指令就会把 1 存到 DM 中。</p></li><li><p>我们为什么要对 GPR 采用内部转发机制？如果不采用内部转发机制，我们要怎样才能解决这种情况下的转发需求呢？</p><p>GPR 采用内部转发机制相当于 MW 流水线寄存器的值直接实时反馈到 GPR 的输出端，从而当前处于 D 级的指令可以直接用到对应寄存器的值，即 W 级到 D 级的转发。</p><p>如果不采用内部转发机制，需要额外建立从 MW 流水线寄存器转发到 D 级的数据通路。</p></li><li><p>为什么 0 号寄存器需要特殊处理？</p><p>因为指令可以对 0 号寄存器赋值，只是不会造成实际作用，但是转发过程中如果不特判就默认 0 号寄存器的值被更改了，从而造成错误。</p></li><li><p>什么是 “最新产生的数据”？</p><p>根据指令的执行顺序，越后执行的指令更改的寄存器的值越新，按照 DE、EM、MW 的顺序，越靠前所转发出的信息越新，因此优先级更高。</p></li></ol></li><li><p>在 AT 方法讨论转发条件的时候，只提到了 “供给者需求者的 A 相同，且不为 0”，但在 CPU 写入 GRF 的时候，是有一个 WE 信号来控制是否要写入的。为何在 AT 方法中不需要特判 we 呢？为了<strong>用且仅用</strong> A 和 T 完成转发，在翻译出 A 的时候，要结合 WE 做什么操作呢？</p><ul><li><p>AT 法要求：只要<strong>当前位点的读取寄存器地址和某转发输入来源的写入寄存器地址相等且不为 0</strong></p><p>那么既然是要写入的，WE 必然为 1，因此不用特判，如果不需要写入，我们零待写入地址 <code>GRFA3</code> 为 0，向 0 号寄存器里写入数据相当于不写</p></li><li><p>如果 WE 是 0，我们把 <code>GRFA3</code> 设为 <code>5'b00000</code> 即可</p></li></ul></li></ol><h3 id="在线测试相关说明"><a class="anchor" href="#在线测试相关说明">#</a> 在线测试相关说明</h3><p>在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</p><p>如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证<strong>覆盖</strong>了所有需要测试的情况；如果你是<strong>完全随机</strong>生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了<strong>特殊的策略，<strong>比如构造连续数据冒险序列，请你描述一下你使用的策略如何</strong>结合了随机性</strong>达到强测的效果。</p><p>此思考题请同学们结合自己测试 CPU 使用的具体手段，按照自己的实际情况进行回答。</p><ul><li><p>我的测试方法是利用随机生成数据进行大范围测试，对于随机数据无法覆盖的点，通过手动构造特殊样例进行测试</p></li><li><p>对于随机数据生成，我采用了对于指令进行分类，进行测试，生成的指令仅包括 <code>$1</code> ， <code>$2</code> ， <code>$3</code> ， <code>$31</code> ， <code>$4</code> ， <code>$5</code> 这些寄存器，以增加相邻指令寄存器复用的概率，提高冲突发生的概率</p></li><li><p>生成器采用教程中所述的公共跳转区的做法，即</p><pre><code class="language-assembly"># 刚开始用ori和lui对寄存器赋初始值

jal subtest1
back1:

jal subtest2
back2:

endtest:
beq $0, $0, endtest

subtest1:
# 这里生成长度约为10~15条的随机指令
# 为了避免死循环，beq指令均跳转到endsubtest处
endsubtest1:
la $ra, back1
jr $ra

subtest2:
# ...
endsubtest2:
la $ra, back2
jr $ra
</code></pre></li><li><p>根据最终覆盖性测试的结果，生成的指令有以下部分未被覆盖，大部分是 load 指令，这是因为 load 指令的地址处理难以解决的原因</p><p><img data-src="https://i.loli.net/2021/12/01/7nWBsxjHGQfcryv.png" alt="image-20211123170331326"></p></li></ul><p>对于这些指令，我们采用手动构造测试样例进行测试即可</p><ul><li>总结来看，随机数据生成加上一定的策略可以进行处理大量的冒险类型，但是对于无法覆盖的，就需要手动构造样例</li><li>手动构造样例时可以考虑转发的来源和接受源，以全面测试<ul><li>D 级需求: E-&gt;D (如序列 <code>jal-addu</code> ), M-&gt;D (如序列 <code>jal-nop-addu</code> )(W-&gt;D 隐藏于 GRF 的内部转发中)</li><li>E 级需求: M-&gt;E (如序列 <code>addu-addu</code> ), W-&gt;E (如序列 <code>addu-nop-addu</code> )</li><li>M 级需求: W-&gt;M (如序列 <code>addu-sw</code> )</li></ul></li></ul><div class="tags"><a href="/tags/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag"><i class="ic i-tag"></i> 北航计算机组成原理</a> <a href="/tags/Verilog/" rel="tag"><i class="ic i-tag"></i> Verilog</a> <a href="/tags/MIPS/" rel="tag"><i class="ic i-tag"></i> MIPS</a> <a href="/tags/%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/" rel="tag"><i class="ic i-tag"></i> 流水线CPU</a> <a href="/tags/P5%E8%AF%BE%E4%B8%8B/" rel="tag"><i class="ic i-tag"></i> P5课下</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2021-12-01 23:39:18" itemprop="dateModified" datetime="2021-12-01T23:39:18+08:00">2021-12-01</time> </span><span id="2021/12/01/BUAA-CO-2021/P5/P5课下/" class="item leancloud_visitors" data-flag-title="P5 课下学习 — 流水线 CPU 设计 (1)" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="FL 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="FL 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="FL 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>FL <i class="ic i-at"><em>@</em></i>FlyingLandlord's Blog</li><li class="link"><strong>本文链接：</strong> <a href="http://flyinglandlord.github.io/2021/12/01/BUAA-CO-2021/P5/P5%E8%AF%BE%E4%B8%8B/" title="P5 课下学习 — 流水线 CPU 设计 (1)">http://flyinglandlord.github.io/2021/12/01/BUAA-CO-2021/P5/P5课下/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/11/17/BUAA-CO-2021/P4/P4%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95%E6%B8%B8%E8%AE%B0/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;api.yimian.xyz&#x2F;img?type&#x3D;wallpaper&amp;size&#x3D;1920x1080?381692" title="P4课上测试"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 北航计算机组成原理</span><h3>P4课上测试</h3></a></div><div class="item right"><a href="/2021/12/02/BUAA-CO-2021/P5/P5%E8%AF%BE%E4%B8%8A1&2/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;api.yimian.xyz&#x2F;img?type&#x3D;wallpaper&amp;size&#x3D;1920x1080?848926" title="P5课上测试1&amp;2"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 北航计算机组成原理</span><h3>P5课上测试1&2</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#p5%E8%AF%BE%E4%B8%8B%E9%A1%B9%E7%9B%AE%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E8%AE%BE%E8%AE%A11"><span class="toc-number">1.</span> <span class="toc-text">P5 课下项目：流水线 CPU 设计（1）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">总体设计概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">1.1.1.</span> <span class="toc-text">命名规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%90%AD%E5%BB%BA%E8%A6%81%E7%82%B9"><span class="toc-number">1.1.2.</span> <span class="toc-text">一些搭建要点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#d%E7%BA%A7decode%E8%AF%91%E7%A0%81"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">D 级 (Decode &#x2F; 译码)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e%E7%BA%A7execute%E6%89%A7%E8%A1%8C"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">E 级 (Execute &#x2F; 执行)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#m%E7%BA%A7memory%E5%82%A8%E5%AD%98"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">M 级 (Memory &#x2F; 储存)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#w%E7%BA%A7write%E5%9B%9E%E5%86%99"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">W 级 (Write &#x2F; 回写)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#f%E7%BA%A7fetch%E5%8F%96%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">F 级 (Fetch &#x2F; 取指令)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ifu%E5%8F%96%E6%8C%87%E5%8D%95%E5%85%83"><span class="toc-number">1.1.2.5.1.</span> <span class="toc-text">IFU（取指单元）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d%E7%BA%A7decode%E8%AF%91%E7%A0%81-2"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">D 级 (Decode &#x2F; 译码)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fd_regfd%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.1.2.6.1.</span> <span class="toc-text">FD_REG（F&#x2F;D 级流水线寄存器）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d_grf%E5%AF%84%E5%AD%98%E5%99%A8%E5%A0%86"><span class="toc-number">1.1.2.6.2.</span> <span class="toc-text">D_GRF（寄存器堆）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d_ext%E4%BD%8D%E6%89%A9%E5%B1%95"><span class="toc-number">1.1.2.6.3.</span> <span class="toc-text">D_EXT（位扩展）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d_cmp%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-number">1.1.2.6.4.</span> <span class="toc-text">D_CMP（比较器）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d_npc%E6%AC%A1%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97%E5%8D%95%E5%85%83"><span class="toc-number">1.1.2.6.5.</span> <span class="toc-text">D_NPC（次地址计算单元）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.2.6.6.</span> <span class="toc-text">控制信号说明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e%E7%BA%A7execute%E6%89%A7%E8%A1%8C-2"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">E 级 (Execute &#x2F; 执行)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#de_regde%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.1.2.7.1.</span> <span class="toc-text">DE_REG（D&#x2F;E 级流水线寄存器）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#e_alu%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83"><span class="toc-number">1.1.2.7.2.</span> <span class="toc-text">E_ALU（算术逻辑单元）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#m%E7%BA%A7memory%E5%82%A8%E5%AD%98-2"><span class="toc-number">1.1.2.8.</span> <span class="toc-text">M 级 (Memory &#x2F; 储存)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#em_regem%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.1.2.8.1.</span> <span class="toc-text">EM_REG（E&#x2F;M 级流水线寄存器）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#m_dm%E6%95%B0%E6%8D%AE%E5%82%A8%E5%AD%98%E5%99%A8"><span class="toc-number">1.1.2.8.2.</span> <span class="toc-text">M_DM（数据储存器）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#w%E7%BA%A7write%E5%9B%9E%E5%86%99-2"><span class="toc-number">1.1.2.9.</span> <span class="toc-text">W 级 (Write &#x2F; 回写)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mw_regmw%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.1.2.9.1.</span> <span class="toc-text">MW_REG（M&#x2F;W 级流水线寄存器）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">冲突处理方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91"><span class="toc-number">1.2.1.</span> <span class="toc-text">转发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="toc-number">1.2.2.</span> <span class="toc-text">阻塞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88"><span class="toc-number">1.3.</span> <span class="toc-text">思考题参考答案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%86%92%E9%99%A9"><span class="toc-number">1.3.1.</span> <span class="toc-text">流水线冒险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">1.3.2.</span> <span class="toc-text">数据冒险的分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#at-%E6%B3%95%E5%A4%84%E7%90%86%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9"><span class="toc-number">1.3.3.</span> <span class="toc-text">AT 法处理流水线数据冒险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E"><span class="toc-number">1.3.4.</span> <span class="toc-text">在线测试相关说明</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2021/09/15/BUAA-CO-2021/Pre/Logisim%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/" rel="bookmark" title="Logisim斐波那契电路">Logisim斐波那契电路</a></li><li><a href="/2021/09/25/BUAA-CO-2021/Pre/%E5%85%B3%E4%BA%8ECPU%E8%BE%93%E5%87%BA%E5%BA%8F%E5%88%97%E6%A3%80%E6%9F%A5%E9%A2%98%E7%9A%84%E8%B0%83%E8%AF%95%E5%BB%BA%E8%AE%AE/" rel="bookmark" title="CPU输出序列检查调试方法">CPU输出序列检查调试方法</a></li><li><a href="/2021/09/25/BUAA-CO-2021/Pre/Verilog%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%83%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93(Part1)/" rel="bookmark" title="Verilog 学习笔记（1）">Verilog 学习笔记（1）</a></li><li><a href="/2021/09/25/BUAA-CO-2021/Pre/Verilog%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%83%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93(Part2)/" rel="bookmark" title="Verilog 学习笔记（2）">Verilog 学习笔记（2）</a></li><li><a href="/2021/09/30/BUAA-CO-2021/Pre/%E8%B0%88%E4%B8%80%E8%B0%88MIPS%E6%B1%87%E7%BC%96Challenge%E9%A2%98/" rel="bookmark" title="MIPS汇编哈密顿回路">MIPS汇编哈密顿回路</a></li><li><a href="/2021/10/13/BUAA-CO-2021/Pre/Logisim%E5%A4%8D%E4%B9%A0/" rel="bookmark" title="Logisim Pre考前复习">Logisim Pre考前复习</a></li><li><a href="/2021/10/13/BUAA-CO-2021/Pre/Verilog%E5%A4%8D%E4%B9%A0/" rel="bookmark" title="Verilog Pre考前复习">Verilog Pre考前复习</a></li><li><a href="/2021/10/13/BUAA-CO-2021/Pre/Pre%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95/" rel="bookmark" title="Pre课上测试游记">Pre课上测试游记</a></li><li><a href="/2021/10/20/BUAA-CO-2021/P0/P0%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95%E6%B8%B8%E8%AE%B0/" rel="bookmark" title="P0课上测试游记">P0课上测试游记</a></li><li><a href="/2021/10/24/BUAA-CO-2021/P1/P1%E8%AF%BE%E4%B8%8B%E5%AD%A6%E4%B9%A0/" rel="bookmark" title="P1课下学习">P1课下学习</a></li><li><a href="/2021/10/27/BUAA-CO-2021/P1/P1%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95%E6%B8%B8%E8%AE%B0/" rel="bookmark" title="P1课上测试游记">P1课上测试游记</a></li><li><a href="/2021/11/01/BUAA-CO-2021/P2/P2%E8%AF%BE%E4%B8%8B%E5%AD%A6%E4%B9%A0/" rel="bookmark" title="P2课下学习">P2课下学习</a></li><li><a href="/2021/11/03/BUAA-CO-2021/P2/P2%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95%E6%B8%B8%E8%AE%B0/" rel="bookmark" title="P2课上测试游记">P2课上测试游记</a></li><li><a href="/2021/11/10/BUAA-CO-2021/P3/P3%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95%E6%B8%B8%E8%AE%B0/" rel="bookmark" title="P3课上测试游记">P3课上测试游记</a></li><li><a href="/2021/11/13/BUAA-CO-2021/P3/CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/" rel="bookmark" title="P3课下学习—单周期CPU设计(1)">P3课下学习—单周期CPU设计(1)</a></li><li><a href="/2021/11/13/BUAA-CO-2021/P4/CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/" rel="bookmark" title="P4课下学习—单周期CPU设计(2)">P4课下学习—单周期CPU设计(2)</a></li><li><a href="/2021/11/17/BUAA-CO-2021/P4/P4%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95%E6%B8%B8%E8%AE%B0/" rel="bookmark" title="P4课上测试">P4课上测试</a></li><li class="active"><a href="/2021/12/01/BUAA-CO-2021/P5/P5%E8%AF%BE%E4%B8%8B/" rel="bookmark" title="P5课下学习—流水线CPU设计(1)">P5课下学习—流水线CPU设计(1)</a></li><li><a href="/2021/12/02/BUAA-CO-2021/P5/P5%E8%AF%BE%E4%B8%8A1&2/" rel="bookmark" title="P5课上测试1&2">P5课上测试1&2</a></li><li><a href="/2021/12/08/BUAA-CO-2021/P6/P6%E8%AF%BE%E4%B8%8A&%E8%AF%BE%E4%B8%8B/" rel="bookmark" title="P6课下&课上总结">P6课下&课上总结</a></li><li><a href="/2021/12/15/BUAA-CO-2021/P7/P7%E8%AF%BE%E4%B8%8A&%E8%AF%BE%E4%B8%8B/" rel="bookmark" title="P7课下&课上总结">P7课下&课上总结</a></li><li><a href="/2021/12/29/BUAA-CO-2021/P8/P8%E8%AF%BE%E4%B8%8A&%E8%AF%BE%E4%B8%8B/" rel="bookmark" title="P8课下&课上总结">P8课下&课上总结</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="FL" data-src="/images/avatar.jpg"><p class="name" itemprop="name">FL</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">32</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">5</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">36</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZseWluZ2xhbmRsb3Jk" title="https:&#x2F;&#x2F;github.com&#x2F;flyinglandlord"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjI2NDUzNzcxNjFAcXEuY29t" title="mailto:2645377161@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/11/17/BUAA-CO-2021/P4/P4%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95%E6%B8%B8%E8%AE%B0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/12/02/BUAA-CO-2021/P5/P5%E8%AF%BE%E4%B8%8A1&2/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/11/13/BUAA-CO-2021/P3/CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/" title="P3课下学习—单周期CPU设计(1)">P3课下学习—单周期CPU设计(1)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/11/10/BUAA-CO-2021/P3/P3%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95%E6%B8%B8%E8%AE%B0/" title="P3课上测试游记">P3课上测试游记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="分类于 北航操作系统">北航操作系统</a></div><span><a href="/2022/04/22/BUAA-OS-2022/lab0-lab2/lab0-lab2_Summary/" title="lab0-lab2总结">lab0-lab2总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/10/27/BUAA-CO-2021/P1/P1%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95%E6%B8%B8%E8%AE%B0/" title="P1课上测试游记">P1课上测试游记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="分类于 北航操作系统">北航操作系统</a></div><span><a href="/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab2/" title="BUAA-OS Lab2实验总结">BUAA-OS Lab2实验总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/11/01/BUAA-CO-2021/P2/P2%E8%AF%BE%E4%B8%8B%E5%AD%A6%E4%B9%A0/" title="P2课下学习">P2课下学习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/09/25/BUAA-CO-2021/Pre/Verilog%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%83%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93(Part1)/" title="Verilog 学习笔记（1）">Verilog 学习笔记（1）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="分类于 北航操作系统">北航操作系统</a></div><span><a href="/2022/06/15/BUAA-OS-2022/lab4/doc-lab4/" title="BUAA-OS Lab4实验总结">BUAA-OS Lab4实验总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/12/29/BUAA-CO-2021/P8/P8%E8%AF%BE%E4%B8%8A&%E8%AF%BE%E4%B8%8B/" title="P8课下&amp;课上总结">P8课下&课上总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="分类于 北航操作系统">北航操作系统</a></div><span><a href="/2022/06/15/BUAA-OS-2022/lab3/doc-lab3/" title="BUAA-OS Lab3实验总结">BUAA-OS Lab3实验总结</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">FL @ Test Blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/12/01/BUAA-CO-2021/P5/P5课下/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>