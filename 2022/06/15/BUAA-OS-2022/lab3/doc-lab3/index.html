<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="FlyingLandlord's Blog" href="http://flyinglandlord.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="FlyingLandlord's Blog" href="http://flyinglandlord.github.io/atom.xml"><link rel="alternate" type="application/json" title="FlyingLandlord's Blog" href="http://flyinglandlord.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="北航操作系统,OS,Lab3"><link rel="canonical" href="http://flyinglandlord.github.io/2022/06/15/BUAA-OS-2022/lab3/doc-lab3/"><title>BUAA-OS Lab3 实验总结 - 北航操作系统 | Test Blog = FlyingLandlord's Blog</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">BUAA-OS Lab3 实验总结</h1><div class="meta"><span class="item" title="创建时间：2022-06-15 20:25:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-06-15T20:25:00+08:00">2022-06-15</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Test Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/assets/BangD.jpg"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="item" rel="index" title="分类于 北航操作系统"><span itemprop="name">北航操作系统</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://flyinglandlord.github.io/2022/06/15/BUAA-OS-2022/lab3/doc-lab3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="FL"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="FlyingLandlord's Blog"></span><div class="body md" itemprop="articleBody"><h1 id="lab-3-实验总结"><a class="anchor" href="#lab-3-实验总结">#</a> lab-3 实验总结</h1><h2 id="实验思考题"><a class="anchor" href="#实验思考题">#</a> 实验思考题</h2><h3 id="thinking-31"><a class="anchor" href="#thinking-31">#</a> Thinking 3.1</h3><p><strong>思考 envid2env 函数:</strong></p><p><strong>为什么 envid2env 中需要判断 e-&gt;env_id != envid 的情况？如果没有这步判断会发生什么情况？</strong></p><p>在判断前，我们是通过 <code>e = &amp;envs[ENVX(envid)];</code> 获取进程控制块的，这表明 <code>e-&gt;env_id</code> 一定与 <code>envid</code> 在低 10 位上相同，因为 <code>ENVX(envid)</code> 就是通过低 10 位的序号来访问 <code>struct Env</code> 结构体的。</p><p>但在 ASID 上却并不一定相同。若没有这步判断，则会查询到一个<strong>不存在</strong>的进程，导致程序出错。</p><p>究其原因，进程控制块是可以重复使用的，如果一个进程结束之后，这一个控制块会被回收再利用，这会导致出错。</p><h3 id="thinking-32"><a class="anchor" href="#thinking-32">#</a> Thinking 3.2</h3><p><strong>结合 include/mmu.h 中的地址空间布局，思考 env_setup_vm 函数：</strong></p><p><strong>・UTOP 和 ULIM 的含义分别是什么，UTOP 和 ULIM 之间的区域与 UTOP 以下的区域相比有什么区别？</strong></p><p><strong>・请结合系统自映射机制解释代码中 pgdir [PDX (UVPT)]=env_cr3 的含义。</strong></p><p><strong>・谈谈自己对进程中物理地址和虚拟地址的理解。</strong></p><p><code>UTOP = 0x7f400000</code> ，是为用户所能操纵的地址空间的最大值； <code>ULIM = 0x80000000</code> ，是操作系统分配给用户地址空间的最大值。两者之间的区域对用户进程而言是一个只读片段，保存着用户页表 UVPT、 <code>struct Page</code> 、 <code>struct Env</code> ，显然这些都是用户程序不允许动的。<strong>UTOP</strong> 以下的区域就可以被用户程序所读写。</p><p>由自映射机制可得， <code>pgdir[PDX(UVPT)]</code> 就代表页表起始地址所对应的<strong>页目录项</strong>。 <code>env_cr3</code> 是该进程的页目录物理地址，这样即可通过页表项的虚拟地址准确找到物理地址。</p><ul><li>可以理解为多个进程都可以使用<strong> UTOP</strong> 以下的虚拟地址，但若进程间没有共享段的话，相同的虚拟地址对应于不同的物理地址。进程直接操作虚拟地址，操作系统则需要建立起不同进程的虚拟地址对物理地址的映射关系</li><li>而在<strong> ULIM</strong> 之上，虚拟地址和物理地址是是直接映射的，也就是说相同的虚拟页，在<strong> ULIM</strong> 之上会有和<strong> ULIM</strong> 之下一模一样的一份映射存在</li></ul><h3 id="thinking-33"><a class="anchor" href="#thinking-33">#</a> Thinking 3.3</h3><p><strong>找到 user_data 这一参数的来源，思考它的作用。没有这个参数可不可以？为什么？（可以尝试说明实际的应用场景，举一个实际的库中的例子）</strong></p><p>使用代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 最先调用的是 load_icode 函数</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">load_elf</span><span class="token punctuation">(</span>binary<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token operator">&amp;</span>entry_point<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>e<span class="token punctuation">,</span> load_icode_mapper<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 在调用的 load_elf 函数中，将 (void *) e 转化为 (void *) user_data，这体现在函数的定义上</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">load_elf</span><span class="token punctuation">(</span>u_char <span class="token operator">*</span>binary<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> u_long <span class="token operator">*</span>entry_point<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>user_data<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>              <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>map<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 也体现对 load_icode_mapper 函数的调用上</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">map</span><span class="token punctuation">(</span>phdr<span class="token operator">-></span>p_vaddr<span class="token punctuation">,</span> phdr<span class="token operator">-></span>p_memsz<span class="token punctuation">,</span> binary <span class="token operator">+</span> phdr<span class="token operator">-></span>p_offset<span class="token punctuation">,</span> phdr<span class="token operator">-></span>p_filesz<span class="token punctuation">,</span> user_data<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 可见最后一个参数赫然是原先的进程指针</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">// 在函数 load_icode_mapper 中也证实了这一点</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>env <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span><span class="token punctuation">)</span>user_data<span class="token punctuation">;</span></pre></td></tr></table></figure><p>如果没有这个<strong>进程指针</strong>，那么后续步骤将无法完成。</p><p>这一步操作也使用了 C 语言 <code>void *</code> 类型的指针可以转化成任意类型指针的特性</p><h3 id="thinking-34"><a class="anchor" href="#thinking-34">#</a> Thinking 3.4</h3><p><strong>结合 load_icode_mapper 的参数以及二进制镜像的大小，考虑该函数可能会面临哪几种复制的情况？你是否都考虑到了？</strong></p><p>复杂的情况其实教程中的图示已经给出了：</p><p><img data-src="https://img2020.cnblogs.com/blog/2326051/202108/2326051-20210815171239334-1652037699.png" alt="img"></p><p><code>.text &amp; .data</code> ：</p><ul><li>刚开始的 va 没有页对齐，需要考虑 offset 那一段</li><li>中间的普通段，正常加载即可</li><li>最后一段，即前半部分属于 <code>.test &amp; .data</code> ，后半部分属于 <code>.bss</code> ，没有页对齐的情况</li><li>考虑长度：有没有可能 <code>.text &amp; .data</code> 不到一页大小呢？</li></ul><p><code>.bss</code> ：</p><ul><li>第一段，需要同前半段的 <code>.test &amp; .data</code> 段协同考虑没有页对齐的情况</li><li>中间的普通段正常加载</li><li>最后一段，即前半部分属于 <code>.bss</code> ，后半段在需要复制的内容之外，这时需要补 0（使用 bzero）</li><li>考虑长度：这里是不是也有可能不到一页大小？</li></ul><h3 id="thinking-35"><a class="anchor" href="#thinking-35">#</a> Thinking 3.5</h3><p><strong>思考上面这一段话，并根据自己在 lab2 中的理解，回答：</strong></p><p><strong>•</strong> <strong>你认为这里的 env_tf.pc 存储的是物理地址还是虚拟地址？</strong></p><p><strong>・你觉得 entry_point 其值对于每个进程是否一样？该如何理解这种统一或不同？</strong></p><p>PC 存的显然为<strong>虚拟地址</strong>，在 Lab3-2-Extra 中也利用了这一点</p><p><code>entry_poing</code> 对每个进程都是一样的， <code>*entry_point = ehdr-&gt;e_entry;</code> 尽管不同进程其实虚拟地址一样，但加载的二进制文件、页表肯定是不一样的。每个进程起始地址统一会降低操作系统的复杂度，但在<strong>部分</strong>相同虚拟地址中的内容不同也区分了不同的进程。</p><h3 id="thinking-36"><a class="anchor" href="#thinking-36">#</a> Thinking 3.6</h3><p><strong>请查阅相关资料解释，上面提到的 epc 是什么？为什么要将 env_tf.pc 设置为 epc 呢？</strong></p><p>EPC 寄存器是<strong> CP0 寄存器组</strong>中的一个寄存器，用来存放异常中断发生时进程正在执行的指令地址（一般该地址对应的指令还未被执行）。切换进程时，相当于施加了一个异常，这时硬件会自动帮我们把当前 PC 值保存在 EPC 寄存器中，所以下次再轮到这个进程执行时，<strong>直接从该 PC 对应地址开始执行</strong>，而不是从头执行。</p><p>考虑异常情况，如果异常（受害）指令位于延迟槽中，这时 CP0 的 Cause 寄存器 BD 位是高电平，则 EPC+4 才是受害指令的 PC 值</p><h3 id="thinking-37"><a class="anchor" href="#thinking-37">#</a> Thinking 3.7</h3><p><strong>关于 TIMESTACK，请思考以下问题：</strong></p><p><strong>•</strong> <strong>操作系统在何时将什么内容存到了 TIMESTACK 区域</strong></p><p><strong>•</strong> <strong>TIMESTACK 和 env_asm.S 中所定义的 KERNEL_SP 的含义有何不同</strong></p><p>在 <code>env_destory</code> 和 <code>env_run</code> 函数中利用到了<strong> TIMESTACK</strong> 区域，前者将自身进程栈中存放的内容赋值到该区域，后者将该区域的内容复制到当前进程的状态中，以便切换到下一进程。</p><pre><code class="language-asm"> //在stackframe.S中，异常处理会将栈指针置于TIMESTACK处
 //这样就能在发生异常时将当前进程状态存入TIMESTACK
 //env_destory销毁本身进程时也是如此
 li  sp, 0x82000000
 lw  sp, KERNEL_SP
</code></pre><p><strong>我们结合 Lab4 的知识，甚至可以认为 TIMESTACK 就是系统进程切换时使用的栈，保存了内核态上下文，而 KERNEL_SP 保存了 TRAPFRAME 是用户态陷入内核态（可以是中断，可以是系统调用）保存的上下文</strong></p><h3 id="thinking-38"><a class="anchor" href="#thinking-38">#</a> Thinking 3.8</h3><p><strong>试找出上述 5 个异常处理函数的具体实现位置。</strong></p><p><code>handle_int</code> 函数在<strong> genex.S</strong> 文件中， <code>handle_sys</code> 函数在<strong> syscall.S</strong> 文件中。另外三个函数 <code>handle_reserved</code> 、 <code>handle_tlb</code> 、 <code>handle_mod</code> 都在<strong> genex.S</strong> 文件中，没有直接明确的函数名，是靠拼接而成，具体声明位于最后，但定义在最开始。</p><h3 id="thinking-39"><a class="anchor" href="#thinking-39">#</a> Thinking 3.9</h3><p><strong>阅读 kclock_asm.S 和 genex.S 两个文件，并尝试说出 set_timer 和 timer_irq 函数中每行汇编代码的作用</strong></p><pre><code class="language-asm">LEAF(set_timer)
//对定时器的初始化
	li t0, 0xc8
	sb t0, 0xb5000100			//向0xb5000100地址写入0xc8
	sw  sp, KERNEL_SP			//保存当前栈指针
	//把CP0_STATUS第12位和第0位置1，允许4号中断，并表示开启了中断，禁止再次响应中断
 	setup_c0_status STATUS_CU0|0x1001 0
	jr ra						//函数返回
	nop							//延迟槽
END(set_timer)
 
timer_irq:
	sb zero, 0xb5000110			//向地址0xb5000110写入0
1:  
	j   sched_yield				//进入进程调度函数，调度下一个进程
	nop							//延迟槽
    j   ret_from_exception		//跳转到ret_from_exception函数，执行rfe指令，从异常中返回
	nop
</code></pre><h3 id="thinking-310"><a class="anchor" href="#thinking-310">#</a> Thinking 3.10</h3><p><strong>阅读相关代码，思考操作系统是怎么根据时钟周期切换进程的。</strong></p><p>进程装在两个队列中，一次运行一个进程。定时器周期性<strong>产生中断</strong>，使得当前进程被迫停止，通过执行 <code>sched_yield</code> 函数，来进行进程的调度。（这一部分在 <code>kclock_asm.S</code> 的 <code>time_irq</code> 中）</p><p>若该进程时间片还未用完，则可用时间片数量－1，否则会切换到下一个进程，保存上下文。并将原来的进程送到另一个队列的末尾，若进程不处于 RUNNABLE 状态，则会进行其他处理。（这一部分在 <code>sched.c</code> 的 <code>sched_yield</code> 中）</p><p>值得注意的是为什么这里需要使用两个链表来保存调度进程呢？考虑如果当前没有任何可运行的进程时，如果使用一个队列加入队尾，那么就会无限循环下去，使用两个队列就可以在此时报错 <code>panic(&quot;no runnable env&quot;);</code></p><h2 id="实验难点图示"><a class="anchor" href="#实验难点图示">#</a> 实验难点图示</h2><p>本次实验总体来说，第一部分相较于第二部分难度更大</p><h3 id="内存空间分布"><a class="anchor" href="#内存空间分布">#</a> 内存空间分布</h3><p><img data-src="https://img2020.cnblogs.com/blog/2324282/202104/2324282-20210422151222369-1152440206.png" alt="image"></p><ul><li>搞清楚用户空间最大使用内存大小为 2GB</li><li>发现 ULIM 下面的页其实在 ULIM 上面有一份直接映射（其实存在了两次）</li><li>总结：ULIM 上面其实是<strong>物理地址空间</strong>，ULIM 下面其实是<strong>用户虚拟地址空间</strong>，两者合在一起是<strong>内核虚拟地址空间</strong>，搞清楚这些之间的区别，Lab2 和 Lab3 都豁然开朗</li></ul><h3 id="进程映像的加载"><a class="anchor" href="#进程映像的加载">#</a> 进程映像的加载</h3><figure class="highlight mermaid"><figcaption data-lang="mermaid"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">graph</span> LR<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>function1<span class="token text string">("load_icode&lt;br  />分配内存&lt;br  />装入内存")</span> <span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">调用</span><span class="token arrow operator">.-></span></span>  function2<span class="token text string">(load_elf&lt;br  />解析ELF&lt;br  />将ELF复制进内存)</span> <span class="token inter-arrow-label"><span class="token arrow-head arrow operator">--</span><span class="token label property">调用</span><span class="token arrow operator">.-></span></span> function3<span class="token text string">(load_icode_mapper)</span></pre></td></tr></table></figure><p><code>load_icode_mapper</code> 是较难补全的，这主要是实现的难度，而其它的代码主要是理解的难度</p><p>这段代码的补全难在提示很少，很难做到考虑完全所有的情况</p><p>这段学习是可以结合 Lab1 中 ELF 文件的相关知识</p><h3 id="中断处理过程"><a class="anchor" href="#中断处理过程">#</a> 中断处理过程</h3><p><img data-src="https://img2022.cnblogs.com/blog/2785828/202205/2785828-20220502230341528-1659541485.png" alt="img"></p><p>这一部分难在大部分处理由汇编语言完成，因此很难梳理执行过程，这里我找到了网络上的一张图片，讲了进程的加载和调度过程</p><p>难点在于汇编语法不熟悉，汇编语言里使用了大量的宏和 <code>.set</code> 设置，这些都没有在计组课程中详细了解，因此需要边学边读，难度不小，但是考虑到这次 Lab3-2-Extra 就考察了异常处理的内容，因此可见这一部分对课程整体来说还是非常重要的，这在 Lab4 系统调用中也是重中之重，是基础内容</p><h3 id="进程调度"><a class="anchor" href="#进程调度">#</a> 进程调度</h3><p><img data-src="https://img2020.cnblogs.com/blog/2324282/202104/2324282-20210422151327225-1756114823.png" alt="image"></p><p>感觉这部分实验反而没有理论课难，理论课程中讲了许多调度算法，但是我们实现时仅仅实现了最简单的一种，上面是网络上讲时间片轮转调度中画的比较好看的一幅图，可以发现它也使用了双队列调度，首先在一个队列中寻找，如果进程不在可运行状态那么就把它加到另一个队列的末尾，否则就运行，并把这个进程加到另一个队列的末尾</p><p>不过这里还是有疑问，在思考题解答中也提到过，为什么这里需要两个队列呢？</p><h2 id="体会与感想"><a class="anchor" href="#体会与感想">#</a> 体会与感想</h2><ul><li><p>首先对实验有一点建议，就是代码的缩进风格希望能够统一，<strong>实验中的某些 C 语言代码的风格是不一致的，这非常不利于阅读</strong>，我认为作为课程实验的代码，至少应当制定一定的代码规范，包括何时换行，大括号放在哪里，就更不必说汇编代码了，更是乱七八糟，根本没有缩进，有的 nop 前面没有 tab，后面又有了 tab，不仔细阅读，根本搞不明白哪里是宏，哪里是代码，函数从哪里开始，从哪里结束。这几天我去做了 MIT 的 xv6 系统的实验，<strong>代码风格统一，命名规范，甚至开启了将所有警告视作错误的 gcc 编译选项（就是代码里面甚至没有警告）</strong>，<s>而且封装好了汇编函数，所以不需要写汇编</s>，我觉得这是值得我们借鉴的（<s>这条有没有被看见就另说了</s>）</p></li><li><p><strong>Lab2 非常重要</strong>，理解了内存空间，操作系统实验才能继续下去，个人非常希望课程组能在之后的课程中 Lab2 至少画出下图这样详细的图，可以帮助我们理解用户虚拟地址空间、内核虚拟地址空间、物理地址空间的关系，页表页目录进程控制块究竟在上述三个空间中存放在哪里，每一部分空间对应什么，我觉得有助于我们理解， <code>mmu.h</code> 里面的那幅图太抽象了......</p><p><img data-src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20220513203449446.png" alt="image-20220513203449446"></p></li><li><p>汇编语言非常重要，有必要在一开始提示去复习计组的相关内容！这次上机的 Extra 就彰显了汇编的重要性（虽然用 C 也能做，但是汇编更加符合直觉吧～）</p></li><li><p>我不是很会使用 gxemul 的调试功能，所以一旦出了 Bug 就是虚空调试，我觉得这一点需要今后加强学习，否则课上考试不会用这么好的运气，可能会寄～</p></li></ul><div class="tags"><a href="/tags/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="ic i-tag"></i> 北航操作系统</a> <a href="/tags/OS/" rel="tag"><i class="ic i-tag"></i> OS</a> <a href="/tags/Lab3/" rel="tag"><i class="ic i-tag"></i> Lab3</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-06-15 21:26:33" itemprop="dateModified" datetime="2022-06-15T21:26:33+08:00">2022-06-15</time> </span><span id="2022/06/15/BUAA-OS-2022/lab3/doc-lab3/" class="item leancloud_visitors" data-flag-title="BUAA-OS Lab3 实验总结" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="FL 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="FL 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="FL 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>FL <i class="ic i-at"><em>@</em></i>FlyingLandlord's Blog</li><li class="link"><strong>本文链接：</strong> <a href="http://flyinglandlord.github.io/2022/06/15/BUAA-OS-2022/lab3/doc-lab3/" title="BUAA-OS Lab3 实验总结">http://flyinglandlord.github.io/2022/06/15/BUAA-OS-2022/lab3/doc-lab3/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/06/15/BUAA-OS-2022/lab4/doc-lab4/" itemprop="url" rel="prev" data-background-image="&#x2F;assets&#x2F;BangD.jpg" title="BUAA-OS Lab4实验总结"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 北航操作系统</span><h3>BUAA-OS Lab4实验总结</h3></a></div><div class="item right"><a href="/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab2/" itemprop="url" rel="next" data-background-image="&#x2F;assets&#x2F;BangD.jpg" title="BUAA-OS Lab2实验总结"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 北航操作系统</span><h3>BUAA-OS Lab2实验总结</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#lab-3-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">lab-3 实验总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">实验思考题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-31"><span class="toc-number">1.1.1.</span> <span class="toc-text">Thinking 3.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-32"><span class="toc-number">1.1.2.</span> <span class="toc-text">Thinking 3.2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-33"><span class="toc-number">1.1.3.</span> <span class="toc-text">Thinking 3.3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-34"><span class="toc-number">1.1.4.</span> <span class="toc-text">Thinking 3.4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-35"><span class="toc-number">1.1.5.</span> <span class="toc-text">Thinking 3.5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-36"><span class="toc-number">1.1.6.</span> <span class="toc-text">Thinking 3.6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-37"><span class="toc-number">1.1.7.</span> <span class="toc-text">Thinking 3.7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-38"><span class="toc-number">1.1.8.</span> <span class="toc-text">Thinking 3.8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-39"><span class="toc-number">1.1.9.</span> <span class="toc-text">Thinking 3.9</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-310"><span class="toc-number">1.1.10.</span> <span class="toc-text">Thinking 3.10</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E9%9A%BE%E7%82%B9%E5%9B%BE%E7%A4%BA"><span class="toc-number">1.2.</span> <span class="toc-text">实验难点图示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83"><span class="toc-number">1.2.1.</span> <span class="toc-text">内存空间分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%98%A0%E5%83%8F%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.2.2.</span> <span class="toc-text">进程映像的加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">中断处理过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.4.</span> <span class="toc-text">进程调度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%93%E4%BC%9A%E4%B8%8E%E6%84%9F%E6%83%B3"><span class="toc-number">1.3.</span> <span class="toc-text">体会与感想</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/04/22/BUAA-OS-2022/lab0-lab2/lab0-lab2_Summary/" rel="bookmark" title="lab0-lab2总结">lab0-lab2总结</a></li><li><a href="/2022/04/29/BUAA-OS-2022/lab0-lab2/lab2-quiz/" rel="bookmark" title="BUAA-OS Lab2上机">BUAA-OS Lab2上机</a></li><li><a href="/2022/04/29/BUAA-OS-2022/lab3/lab3-quiz/" rel="bookmark" title="BUAA-OS Lab3上机">BUAA-OS Lab3上机</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab0/" rel="bookmark" title="BUAA-OS Lab0实验总结">BUAA-OS Lab0实验总结</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab1/" rel="bookmark" title="BUAA-OS Lab1实验总结">BUAA-OS Lab1实验总结</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab2/" rel="bookmark" title="BUAA-OS Lab2实验总结">BUAA-OS Lab2实验总结</a></li><li class="active"><a href="/2022/06/15/BUAA-OS-2022/lab3/doc-lab3/" rel="bookmark" title="BUAA-OS Lab3实验总结">BUAA-OS Lab3实验总结</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab4/doc-lab4/" rel="bookmark" title="BUAA-OS Lab4实验总结">BUAA-OS Lab4实验总结</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab5/doc-lab5/" rel="bookmark" title="BUAA-OS Lab5实验总结">BUAA-OS Lab5实验总结</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="FL" data-src="/images/avatar.jpg"><p class="name" itemprop="name">FL</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">32</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">5</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">36</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZseWluZ2xhbmRsb3Jk" title="https:&#x2F;&#x2F;github.com&#x2F;flyinglandlord"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjI2NDUzNzcxNjFAcXEuY29t" title="mailto:2645377161@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/06/15/BUAA-OS-2022/lab4/doc-lab4/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab2/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/09/25/BUAA-CO-2021/Pre/Verilog%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%83%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93(Part1)/" title="Verilog 学习笔记（1）">Verilog 学习笔记（1）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="分类于 北航操作系统">北航操作系统</a></div><span><a href="/2022/04/22/BUAA-OS-2022/lab0-lab2/lab0-lab2_Summary/" title="lab0-lab2总结">lab0-lab2总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/11/13/BUAA-CO-2021/P3/CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/" title="P3课下学习—单周期CPU设计(1)">P3课下学习—单周期CPU设计(1)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="分类于 北航操作系统">北航操作系统</a></div><span><a href="/2022/06/15/BUAA-OS-2022/lab3/doc-lab3/" title="BUAA-OS Lab3实验总结">BUAA-OS Lab3实验总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/09/15/BUAA-CO-2021/Pre/Logisim%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/" title="Logisim斐波那契电路">Logisim斐波那契电路</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/09/25/BUAA-CO-2021/Pre/%E5%85%B3%E4%BA%8ECPU%E8%BE%93%E5%87%BA%E5%BA%8F%E5%88%97%E6%A3%80%E6%9F%A5%E9%A2%98%E7%9A%84%E8%B0%83%E8%AF%95%E5%BB%BA%E8%AE%AE/" title="CPU输出序列检查调试方法">CPU输出序列检查调试方法</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/12/29/BUAA-CO-2021/P8/P8%E8%AF%BE%E4%B8%8A&%E8%AF%BE%E4%B8%8B/" title="P8课下&amp;课上总结">P8课下&课上总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/09/30/BUAA-CO-2021/Pre/%E8%B0%88%E4%B8%80%E8%B0%88MIPS%E6%B1%87%E7%BC%96Challenge%E9%A2%98/" title="MIPS汇编哈密顿回路">MIPS汇编哈密顿回路</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/12/15/BUAA-CO-2021/P7/P7%E8%AF%BE%E4%B8%8A&%E8%AF%BE%E4%B8%8B/" title="P7课下&amp;课上总结">P7课下&课上总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/10/13/BUAA-CO-2021/Pre/Verilog%E5%A4%8D%E4%B9%A0/" title="Verilog Pre考前复习">Verilog Pre考前复习</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">FL @ Test Blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/06/15/BUAA-OS-2022/lab3/doc-lab3/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>