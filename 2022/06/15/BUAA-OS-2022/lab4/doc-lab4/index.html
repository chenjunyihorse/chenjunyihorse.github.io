<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="FlyingLandlord's Blog" href="http://flyinglandlord.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="FlyingLandlord's Blog" href="http://flyinglandlord.github.io/atom.xml"><link rel="alternate" type="application/json" title="FlyingLandlord's Blog" href="http://flyinglandlord.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="北航操作系统,OS,Lab4"><link rel="canonical" href="http://flyinglandlord.github.io/2022/06/15/BUAA-OS-2022/lab4/doc-lab4/"><title>BUAA-OS Lab4 实验总结 - 北航操作系统 | Test Blog = FlyingLandlord's Blog</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">BUAA-OS Lab4 实验总结</h1><div class="meta"><span class="item" title="创建时间：2022-06-15 20:25:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-06-15T20:25:00+08:00">2022-06-15</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Test Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/assets/BangD.jpg"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="item" rel="index" title="分类于 北航操作系统"><span itemprop="name">北航操作系统</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://flyinglandlord.github.io/2022/06/15/BUAA-OS-2022/lab4/doc-lab4/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="FL"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="FlyingLandlord's Blog"></span><div class="body md" itemprop="articleBody"><h1 id="lab-4-实验总结"><a class="anchor" href="#lab-4-实验总结">#</a> lab-4 实验总结</h1><h2 id="实验思考题"><a class="anchor" href="#实验思考题">#</a> 实验思考题</h2><h3 id="thinking-41"><a class="anchor" href="#thinking-41">#</a> Thinking 4.1</h3><ul><li><p>内核在保存现场的时候是如何避免破坏通用寄存器的？</p></li><li><p>系统陷入内核调用后可以直接从当时的 <code>$a0−$a3</code> 参数寄存器中得到用户调用 msyscall 留下的信息吗？</p></li><li><p>我们是怎么做到让 sys 开头的函数 “认为” 我们提供了和用户调用 msyscall 时同样的参数的？</p></li><li><p>内核处理系统调用的过程对 Trapframe 做了哪些更改？这种修改对应的用户态的变化是？</p></li></ul><p><strong>【答案】</strong></p><ol><li><p>保存现场时，k0 寄存器暂存了 sp 栈指针的值，k1 寄存器更新 sp 栈指针的值，除 k0、k1 之外所有的通用寄存器都在修改之前被保存了，k0 和 k1 是约定好保留供操作系统使用的寄存器，用户代码不会使用，因此修改也没关系</p></li><li><p>可以，a0-a3 寄存器没有被修改过</p></li><li><p>人工将参数加载到了 sys 开头函数认为的位置，事实上我们利用了 Calling Convention 中的对寄存器的描述直接把参数值存入相应寄存器内，或者压入栈中</p></li><li><p>对 Trapframe 结构体中的 <code>cp0_epc</code> 的值增加了 4，将 sys 开头函数的返回值存入 v0 寄存器，这样保证了系统调用结束后，从 syscall 的下一条开始执行；在发生异常时，存在 EPC 中的受害指令是当前指令，因此我们需要多加一步操作</p></li></ol><h4 id="thinking-42"><a class="anchor" href="#thinking-42">#</a> Thinking 4.2</h4><p>思考下面的问题，并对这个问题谈谈你的理解： 请回顾 lib/env.c 文件中 <code>mkenvid()</code> 函数的实现，该函数不会返回 0，请结合系统调用和 IPC 部分的实现与 envid2env () 函数的行为进行解释。</p><p><strong>【答案】</strong></p><p><img data-src="https://s2.loli.net/2022/06/15/rqfjU2d764XFslR.png" alt="image-20220601135727117"></p><p>由以上 <code>mkenvid()</code> 函数可知，最终返回值的第 11 位始终为一，所以该函数不会返回零，因此不会存在 0 这个 envid，所以 envid2env 中如果是 0 则返回 curenv 功能才能够实现，IPC 部分才可以使用 envid2env 获取当前进程、根据进程 ID 获取进程结构体</p><h3 id="thinking-43"><a class="anchor" href="#thinking-43">#</a> Thinking 4.3</h3><p>思考下面的问题，并对这两个问题谈谈你的理解：</p><ul><li>子进程完全按照 fork () 之后父进程的代码执行，说明了什么？</li><li>但是子进程却没有执行 fork () 之前父进程的代码，又说明了什么？</li></ul><p><strong>【答案】</strong></p><ol><li><p>说明了子进程和父进程具有相同的代码段，也说明了写时复制时确实共享了父进程包括代码在内的所有页面</p></li><li><p>创建子进程时，PC 值设置为了 <code>fork()</code> 的后一个指令，所以子进程没有执行 <code>fork()</code> 之前父进程的代码，然后在程序中也会根据进程 ID 是 0 还是其它值来判断当前进程是父亲还是孩子，从而执行不同的代码段</p></li></ol><h3 id="thinking-44"><a class="anchor" href="#thinking-44">#</a> Thinking 4.4</h3><p>关于 fork 函数的两个返回值，下面说法正确的是：</p><p>A、fork 在父进程中被调用两次，产生两个返回值</p><p>B、fork 在两个进程中分别被调用一次，产生两个不同的返回值</p><p>C、fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值</p><p>D、fork 只在子进程中被调用了一次，在两个进程中各产生一个返回值</p><p><strong>【答案】</strong></p><p>C： <code>fork</code> 在父进程中调用一次，返回两次，在子进程中返回 0，在父进程中返回子进程 ID</p><h3 id="thinking-45"><a class="anchor" href="#thinking-45">#</a> Thinking 4.5</h3><p>我们并不应该对所有的用户空间页都使用 duppage 进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？请结合本章的后续描述 mm/pmap.c 中 mips_vm_init 函数进行的页面映射以及 include/mmu.h 里的内存布局图进行思考。</p><p><strong>【答案】</strong></p><p>需要映射的是 0—USTACKTOP 范围内的空间。</p><p>因为其上的范围，USTACKTOP 到 UXSTACKTOP 之间为用户进程的异常栈和 Invalid memory，而异常栈是进行异常处理的地方，不应映射，不应该受到写时复制机制的保护；Invalid memory 不会用到为空闲区，不需要保护；</p><p>UTOP 以上的空间为内核相关的页表、进程控制块、物理页面管理等部分，对于所有的用户进程都相同，用户进程当然也无权进行更改，因此不需要用 duppage 进行保护。</p><p>综上，需要保护从 UTEXT 到 USTACKTOP 的页表。</p><h3 id="thinking-46"><a class="anchor" href="#thinking-46">#</a> Thinking 4.6</h3><p>在遍历地址空间存取页表项时你需要使用到 vpd 和 vpt 这两个 “指针的指针”，请参考 user/entry.S 和 include/mmu.h 中的相关实现，思考并回答这几个问题：</p><ul><li>vpt 和 vpd 的作用是什么？怎样使用它们？</li><li>从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？</li><li>它们是如何体现自映射设计的？</li><li>进程能够通过这种方式来修改自己的页表项吗？</li></ul><p><strong>【答案】</strong></p><ol><li><p><code>vpd</code> 存放的是页目录基地址（Virtual Page Directory），基地址加页目录项偏移数 <code>PDX(va)</code> 即为 <code>va</code> 对应的页目录项； <code>vpt</code> 为页表基地址（Virtual Page Table），指向页表区域第一个页表项，基地址加页表项偏移数即为 <code>va</code> 对应的页表项。</p><p>如果有效， <code>（*vpd）[va&gt;&gt;22（页目录的索引）]&amp;(~0xfff)</code> 表示二级页表的物理地址，如果有效， <code>(*vpt)[va &gt;&gt; 12]&amp;(~0xfff)</code> 为 <code>va</code> 对应的物理页面地址</p></li><li><p>在用户空间入口函数 <code>entry.S</code> 中，我们可以发现下面的代码</p></li></ol><p><img data-src="https://s2.loli.net/2022/06/15/z7AmeEJfGUZ8RNb.png" alt="image-20220601141211913"></p><p>这里的 globl 定义了全局符号，也就是对于用户代码来说，vpt 和 vpd 就如同全局变量一样，因此进程可以访问这两个地址去读取自身的页表</p><ol start="3"><li>vpd 指向 <code>(UVPT+(UVPT&gt;&gt;12)*4)</code> ，这直接就是自映射的公式，显然使用了自映射技术</li><li>不能，用户进程无权修改自己和内核的页表项，也就是说页表项的标记是没有 PTE_R 的，用户进程必须要通过系统调用陷入内核之后才能进行操作</li></ol><h3 id="thinking-47"><a class="anchor" href="#thinking-47">#</a> Thinking 4.7</h3><p>page_fault_handler 函数中，你可能注意到了一个向异常处理栈复制 Trapframe 运行现场的过程，请思考并回答这几个问题：</p><ul><li>这里实现了一个支持类似于 “中断重入” 的机制，而在什么时候会出现这种 “中断重入”？</li><li>内核为什么需要将异常的现场 Trapframe 复制到用户空间？</li></ul><p><strong>【答案】</strong></p><ol><li><p>用户发生写时复制导致缺页中断并处理这个缺页中断的过程中，有可能还会发生缺页，所以要 “中断重入”，类似于函数嵌套递归调用的方式，要重复处理，直到不再缺页异常。</p></li><li><p>因为我们的 MOS 系统使用微内核设计，将缺页中断的处理交给了用户进程，所以用户进程需要读取 Trapframe 的值获得哪一条指令触发了缺页，从而得到缺的页面是哪一页，并进行调页。用户进程处理完毕恢复现场的时候也要使用 Trapframe 的数据。</p></li></ol><h3 id="thinking-48"><a class="anchor" href="#thinking-48">#</a> Thinking 4.8</h3><p>到这里我们大概知道了这是一个由用户程序处理并由用户程序自身来恢复运行现场的过程，请思考并回答以下几个问题：</p><ul><li>在用户态处理页写入异常，相比于在内核态处理有什么优势？</li><li>从通用寄存器的用途角度讨论，在可能被中断的用户态下进行现场的恢复，要如何做到不破坏现场中的通用寄存器？</li></ul><p><strong>【答案】</strong></p><ol><li><p>减少内核代码的工作量，用户处理出现错误时还可以由内核进行处理，但是如果内核出现错误，就会导致系统崩溃</p></li><li><p>可以看到恢复过程代码如下：</p><pre><code class="language-assembly">// 恢复除了sp寄存器
.macro RESTORE_SOME
.set    mips1
mfc0    t0, CP0_STATUS
ori     t0, 0x3
xori    t0, 0x3
mtc0    t0, CP0_STATUS
//修改cp0_status
lw      v0, TF_STATUS(sp)
li      v1, 0xff00
and     t0, v1
nor     v1, $0, v1
and     v0, v1
or      v0, t0
mtc0    v0, CP0_STATUS
lw      v1, TF_LO(sp)
mtlo    v1
lw      v0, TF_HI(sp)
lw      v1, TF_EPC(sp)
mthi    v0
mtc0    v1, CP0_EPC
// 用v0 v1寄存器恢复非通用寄存器
lw      $31, TF_REG31(sp)
lw      $30, TF_REG30(sp)
lw      $28, TF_REG28(sp)
lw      $25, TF_REG25(sp)
lw      $24, TF_REG24(sp)
lw      $23, TF_REG23(sp)
lw      $22, TF_REG22(sp)
lw      $21, TF_REG21(sp)
lw      $20, TF_REG20(sp)
lw      $19, TF_REG19(sp)
lw      $18, TF_REG18(sp)
lw      $17, TF_REG17(sp)
lw      $16, TF_REG16(sp)
lw      $15, TF_REG15(sp)
lw      $14, TF_REG14(sp)
lw      $13, TF_REG13(sp)
lw      $12, TF_REG12(sp)
lw      $11, TF_REG11(sp)
lw      $10, TF_REG10(sp)
lw      $9, TF_REG9(sp)
lw      $8, TF_REG8(sp)
lw      $7, TF_REG7(sp)
lw      $6, TF_REG6(sp)
lw      $5, TF_REG5(sp)
lw      $4, TF_REG4(sp)
lw      $3, TF_REG3(sp)
lw      $2, TF_REG2(sp)
lw      $1, TF_REG1(sp)
// 通过sp寄存器恢复通用寄存器
.endm
 
.macro RESTORE_ALL
RESTORE_SOME
lw      sp, TF_REG29(sp) /* Deallocate stack  sp已经到达高位，恢复sp，收回栈空间*/
.endm
</code></pre><p>首先不恢复 sp 寄存器，通过 sp 寄存器从栈中读取各个寄存器的值恢复；最后再恢复 sp 的值</p></li></ol><h3 id="thinking-49"><a class="anchor" href="#thinking-49">#</a> Thinking 4.9</h3><p>请思考并回答以下几个问题：</p><ul><li>为什么需要将 set_pgfault_handler 的调用放置在 syscall_env_alloc 之前？</li><li>如果放置在写时复制保护机制完成之后会有怎样的效果？</li><li>子进程是否需要对在 entry.S 定义的字__pgfault_handler 赋值？</li></ul><p><strong>【答案】</strong></p><ol><li>刚开始父子进程的虚拟空间实际上是共享的，在父进程调用 <code>env_alloc</code> 的过程中可能也会发生缺页中断，这时候就需要设置好的 set_pgfault_handler 处理缺页中断</li><li>这样的话发生缺页中断不能够被捕捉，也无法进入缺页中断异常，有可能会向未知页面写入数据导致内核崩溃</li><li>不需要，父子进程初始共享内存，因此子进程__pgfault_handler 的值应当和父进程一致 4</li></ol><h2 id="实验难点图示"><a class="anchor" href="#实验难点图示">#</a> 实验难点图示</h2><h3 id="难点一系统调用过程中的参数传递"><a class="anchor" href="#难点一系统调用过程中的参数传递">#</a> 难点一：系统调用过程中的参数传递</h3><p><img data-src="https://s2.loli.net/2022/06/15/9fJNisqyEQmu1Md.png" alt="image-20220601142816541"></p><p>用户空间向内核传入的参数，syscall_all 中实现的系统调用是如何看到的呢？我觉得这个问题的答案是，其实内核是直接看不到的，但是我们可以在进行系统调用之前做一些操作，伪装成好像有某个函数调用了它并传给了它参数。这就需要用到调用约定，把相应的参数存入相应的寄存器里，这样 syscall_* 函数就可以通过参数直接访问这些数据了。</p><p>如上图所示，参数其实放在了 <code>$a0-$a3</code> ，其余的参数需要压栈，这也就是 <code>syscall.S</code> 中要填写的内容，刚开始没有提示需要看这方面的内容，因此我在理解代码上遇到了一些阻碍。尤其需要注意的是 arg0-arg4 实际上是存在寄存器中的，但是我们仍然在内存中给它们留下了空位，这在编写汇编代码访问参数时尤其需要注意</p><h3 id="难点二系统调用进入内核的全过程"><a class="anchor" href="#难点二系统调用进入内核的全过程">#</a> 难点二：系统调用进入内核的全过程</h3><p>系统调用是通过中断来进行的，syscall () 从用户态到内核态的陷入过程：</p><p><img data-src="https://knowledgehive.github.io/6.828/Lab3-User%20Environments/syscall.png" alt="img"></p><p>从用户态切换到内核态，上下文保存在 Trapframe 中，需要从用户栈切换到内核栈，最后返回时调用 <code>env_pop_tf()</code></p><p>更有意思的应该是第一次进入用户态时，因为之前从未有过中断，所以系统需要假装好像曾就有过一次中断一样， <code>env_pop_tf()</code> 才能顺利进入用户态，这一点的操作在 lab3 就有做过</p><h3 id="难点三用户态fork调用过程"><a class="anchor" href="#难点三用户态fork调用过程">#</a> 难点三：用户态 fork () 调用过程</h3><figure class="highlight mermaid"><figcaption data-lang="mermaid"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">graph</span> TD</pre></td></tr><tr><td data-num="2"></td><td><pre>父进程得到ID <span class="token arrow operator">--></span> 进程分配异常处理栈入口 <span class="token arrow operator">--></span> 创建子进程 <span class="token arrow operator">--></span> 保护页面保护位位置 <span class="token arrow operator">--></span> 分配子进程内存空间 <span class="token arrow operator">--></span> 设置子进程异常处理栈 <span class="token arrow operator">--></span> 唤醒子进程 <span class="token arrow operator">--></span> 返回子进程序号</pre></td></tr><tr><td data-num="3"></td><td><pre>创建子进程 <span class="token arrow operator">--></span> 子进程赋值给变量env  <span class="token arrow operator">--></span> 获得子进程ID <span class="token arrow operator">--></span> 通过索引得到envs数组中的项 <span class="token arrow operator">--></span> 设置parent_id <span class="token arrow operator">--></span> 子进程返回0</pre></td></tr></table></figure><h3 id="难点四vpt和vpd两个指针的用法"><a class="anchor" href="#难点四vpt和vpd两个指针的用法">#</a> 难点四：vpt 和 vpd 两个指针的用法</h3><p>这一点在 Lab4-2 中考到了</p><p>具体两个指针的位置在 <code>entry.S</code> 中，用汇编定义，而 <code>entry.S</code> 其实应该时用户空间的入口</p><p>总结来看用法就是 <code>（*vpd）[va&gt;&gt;22（页目录的索引）]&amp;(~0xfff)</code> 表示二级页表的物理地址， <code>(*vpt)[va &gt;&gt; 12]&amp;(~0xfff)</code> 为 <code>va</code> 对应的物理页面地址，使用前记得提前判断有效位</p><h3 id="难点五缺页中断"><a class="anchor" href="#难点五缺页中断">#</a> 难点五：缺页中断</h3><figure class="highlight mermaid"><figcaption data-lang="mermaid"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">graph</span> LR</pre></td></tr><tr><td data-num="2"></td><td><pre>异常分发 <span class="token arrow operator">--></span> 普通缺页 <span class="token arrow operator">--></span> 页表不缺失 <span class="token arrow operator">--></span> 填入TLB,返回异常地址</pre></td></tr><tr><td data-num="3"></td><td><pre>异常分发 <span class="token arrow operator">--></span> 写时复制</pre></td></tr><tr><td data-num="4"></td><td><pre>普通缺页 <span class="token arrow operator">--></span> 页表中缺失</pre></td></tr><tr><td data-num="5"></td><td><pre>页表中缺失 <span class="token arrow operator">--></span> 出现缺页错误,跳转到分配页面</pre></td></tr></table></figure><p>简单总结一下，page_fault_handle 的栈变化情况：</p><p>陷入：用户栈 -&gt; 内核栈 -&gt; 异常栈；返回：异常栈 -&gt; 用户栈</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIyLzA2LzE1L2kxaFNuQVFmN3prUGQ2Ty5wbmc=">https://s2.loli.net/2022/06/15/i1hSnAQf7zkPd6O.png</span>&quot; alt=&quot;img&quot; style=&quot;zoom: 33%;&quot; /&gt;</p><h2 id="体会和感想"><a class="anchor" href="#体会和感想">#</a> 体会和感想</h2><h3 id="许多地方没有思考准确"><a class="anchor" href="#许多地方没有思考准确">#</a> 许多地方没有思考准确</h3><p>对于 Trapframe、Timestack、用户栈、系统栈、用户异常栈还是有些糊涂</p><p>由于操作寄存器不可避免的需要使用汇编，仍然需要去啃一啃哪些进入离开内核的汇编代码</p><h3 id="c语言省去了很多对寄存器值调用的步骤"><a class="anchor" href="#c语言省去了很多对寄存器值调用的步骤">#</a> C 语言省去了很多对寄存器值调用的步骤</h3><p>函数调用时对寄存器的保存以及传值、恢复等，写 C 时候完全不可见。但与汇编相比较起来，就会感受到高级语言的美好。</p><p>而如果同时需要写 C 代码和汇编代码时，就不得不去考虑这些复杂的情况</p><div class="tags"><a href="/tags/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="ic i-tag"></i> 北航操作系统</a> <a href="/tags/OS/" rel="tag"><i class="ic i-tag"></i> OS</a> <a href="/tags/Lab4/" rel="tag"><i class="ic i-tag"></i> Lab4</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-06-15 21:33:42" itemprop="dateModified" datetime="2022-06-15T21:33:42+08:00">2022-06-15</time> </span><span id="2022/06/15/BUAA-OS-2022/lab4/doc-lab4/" class="item leancloud_visitors" data-flag-title="BUAA-OS Lab4 实验总结" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="FL 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="FL 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="FL 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>FL <i class="ic i-at"><em>@</em></i>FlyingLandlord's Blog</li><li class="link"><strong>本文链接：</strong> <a href="http://flyinglandlord.github.io/2022/06/15/BUAA-OS-2022/lab4/doc-lab4/" title="BUAA-OS Lab4 实验总结">http://flyinglandlord.github.io/2022/06/15/BUAA-OS-2022/lab4/doc-lab4/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/06/15/BUAA-OS-2022/lab5/doc-lab5/" itemprop="url" rel="prev" data-background-image="&#x2F;assets&#x2F;BangD.jpg" title="BUAA-OS Lab5实验总结"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 北航操作系统</span><h3>BUAA-OS Lab5实验总结</h3></a></div><div class="item right"><a href="/2022/06/15/BUAA-OS-2022/lab3/doc-lab3/" itemprop="url" rel="next" data-background-image="&#x2F;assets&#x2F;BangD.jpg" title="BUAA-OS Lab3实验总结"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 北航操作系统</span><h3>BUAA-OS Lab3实验总结</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#lab-4-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">lab-4 实验总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">实验思考题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-41"><span class="toc-number">1.1.1.</span> <span class="toc-text">Thinking 4.1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#thinking-42"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">Thinking 4.2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-43"><span class="toc-number">1.1.2.</span> <span class="toc-text">Thinking 4.3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-44"><span class="toc-number">1.1.3.</span> <span class="toc-text">Thinking 4.4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-45"><span class="toc-number">1.1.4.</span> <span class="toc-text">Thinking 4.5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-46"><span class="toc-number">1.1.5.</span> <span class="toc-text">Thinking 4.6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-47"><span class="toc-number">1.1.6.</span> <span class="toc-text">Thinking 4.7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-48"><span class="toc-number">1.1.7.</span> <span class="toc-text">Thinking 4.8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thinking-49"><span class="toc-number">1.1.8.</span> <span class="toc-text">Thinking 4.9</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E9%9A%BE%E7%82%B9%E5%9B%BE%E7%A4%BA"><span class="toc-number">1.2.</span> <span class="toc-text">实验难点图示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9%E4%B8%80%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">1.2.1.</span> <span class="toc-text">难点一：系统调用过程中的参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9%E4%BA%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">难点二：系统调用进入内核的全过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9%E4%B8%89%E7%94%A8%E6%88%B7%E6%80%81fork%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">难点三：用户态 fork () 调用过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9%E5%9B%9Bvpt%E5%92%8Cvpd%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.2.4.</span> <span class="toc-text">难点四：vpt 和 vpd 两个指针的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9%E4%BA%94%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD"><span class="toc-number">1.2.5.</span> <span class="toc-text">难点五：缺页中断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%93%E4%BC%9A%E5%92%8C%E6%84%9F%E6%83%B3"><span class="toc-number">1.3.</span> <span class="toc-text">体会和感想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B8%E5%A4%9A%E5%9C%B0%E6%96%B9%E6%B2%A1%E6%9C%89%E6%80%9D%E8%80%83%E5%87%86%E7%A1%AE"><span class="toc-number">1.3.1.</span> <span class="toc-text">许多地方没有思考准确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E7%9C%81%E5%8E%BB%E4%BA%86%E5%BE%88%E5%A4%9A%E5%AF%B9%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BC%E8%B0%83%E7%94%A8%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.3.2.</span> <span class="toc-text">C 语言省去了很多对寄存器值调用的步骤</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/04/22/BUAA-OS-2022/lab0-lab2/lab0-lab2_Summary/" rel="bookmark" title="lab0-lab2总结">lab0-lab2总结</a></li><li><a href="/2022/04/29/BUAA-OS-2022/lab0-lab2/lab2-quiz/" rel="bookmark" title="BUAA-OS Lab2上机">BUAA-OS Lab2上机</a></li><li><a href="/2022/04/29/BUAA-OS-2022/lab3/lab3-quiz/" rel="bookmark" title="BUAA-OS Lab3上机">BUAA-OS Lab3上机</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab0/" rel="bookmark" title="BUAA-OS Lab0实验总结">BUAA-OS Lab0实验总结</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab1/" rel="bookmark" title="BUAA-OS Lab1实验总结">BUAA-OS Lab1实验总结</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab2/" rel="bookmark" title="BUAA-OS Lab2实验总结">BUAA-OS Lab2实验总结</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab3/doc-lab3/" rel="bookmark" title="BUAA-OS Lab3实验总结">BUAA-OS Lab3实验总结</a></li><li class="active"><a href="/2022/06/15/BUAA-OS-2022/lab4/doc-lab4/" rel="bookmark" title="BUAA-OS Lab4实验总结">BUAA-OS Lab4实验总结</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab5/doc-lab5/" rel="bookmark" title="BUAA-OS Lab5实验总结">BUAA-OS Lab5实验总结</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="FL" data-src="/images/avatar.jpg"><p class="name" itemprop="name">FL</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">32</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">5</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">36</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZseWluZ2xhbmRsb3Jk" title="https:&#x2F;&#x2F;github.com&#x2F;flyinglandlord"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjI2NDUzNzcxNjFAcXEuY29t" title="mailto:2645377161@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/06/15/BUAA-OS-2022/lab5/doc-lab5/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/06/15/BUAA-OS-2022/lab3/doc-lab3/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/11/13/BUAA-CO-2021/P4/CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/" title="P4课下学习—单周期CPU设计(2)">P4课下学习—单周期CPU设计(2)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/09/25/BUAA-CO-2021/Pre/%E5%85%B3%E4%BA%8ECPU%E8%BE%93%E5%87%BA%E5%BA%8F%E5%88%97%E6%A3%80%E6%9F%A5%E9%A2%98%E7%9A%84%E8%B0%83%E8%AF%95%E5%BB%BA%E8%AE%AE/" title="CPU输出序列检查调试方法">CPU输出序列检查调试方法</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/09/15/BUAA-CO-2021/Pre/Logisim%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/" title="Logisim斐波那契电路">Logisim斐波那契电路</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/10/20/BUAA-CO-2021/P0/P0%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95%E6%B8%B8%E8%AE%B0/" title="P0课上测试游记">P0课上测试游记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/12/15/BUAA-CO-2021/P7/P7%E8%AF%BE%E4%B8%8A&%E8%AF%BE%E4%B8%8B/" title="P7课下&amp;课上总结">P7课下&课上总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/10/27/BUAA-CO-2021/P1/P1%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95%E6%B8%B8%E8%AE%B0/" title="P1课上测试游记">P1课上测试游记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="分类于 北航操作系统">北航操作系统</a></div><span><a href="/2022/04/22/BUAA-OS-2022/lab0-lab2/lab0-lab2_Summary/" title="lab0-lab2总结">lab0-lab2总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="分类于 北航操作系统">北航操作系统</a></div><span><a href="/2022/04/29/BUAA-OS-2022/lab0-lab2/lab2-quiz/" title="BUAA-OS Lab2上机">BUAA-OS Lab2上机</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="分类于 北航操作系统">北航操作系统</a></div><span><a href="/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab2/" title="BUAA-OS Lab2实验总结">BUAA-OS Lab2实验总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/09/30/BUAA-CO-2021/Pre/%E8%B0%88%E4%B8%80%E8%B0%88MIPS%E6%B1%87%E7%BC%96Challenge%E9%A2%98/" title="MIPS汇编哈密顿回路">MIPS汇编哈密顿回路</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">FL @ Test Blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/06/15/BUAA-OS-2022/lab4/doc-lab4/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>