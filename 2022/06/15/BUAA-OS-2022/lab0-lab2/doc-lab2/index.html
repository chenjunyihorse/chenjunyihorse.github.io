<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="FlyingLandlord's Blog" href="http://flyinglandlord.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="FlyingLandlord's Blog" href="http://flyinglandlord.github.io/atom.xml"><link rel="alternate" type="application/json" title="FlyingLandlord's Blog" href="http://flyinglandlord.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="北航操作系统,OS,Lab2"><link rel="canonical" href="http://flyinglandlord.github.io/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab2/"><title>BUAA-OS Lab2 实验总结 - 北航操作系统 | Test Blog = FlyingLandlord's Blog</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">BUAA-OS Lab2 实验总结</h1><div class="meta"><span class="item" title="创建时间：2022-06-15 20:25:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-06-15T20:25:00+08:00">2022-06-15</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Test Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/assets/BangD.jpg"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="item" rel="index" title="分类于 北航操作系统"><span itemprop="name">北航操作系统</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://flyinglandlord.github.io/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="FL"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="FlyingLandlord's Blog"></span><div class="body md" itemprop="articleBody"><h1 id="lab-2-实验总结"><a class="anchor" href="#lab-2-实验总结">#</a> lab-2 实验总结</h1><h2 id="思考题解答"><a class="anchor" href="#思考题解答">#</a> 思考题解答</h2><p><strong>Thinking 2.1</strong></p><p>请你根据上述说明，回答问题：</p><ul><li><p>在我们编写的程序中，指针变量中存储的地址是虚拟地址还是物理地址？</p></li><li><p>MIPS 汇编程序中 lw, sw 使用的是虚拟地址还是物理地址？</p></li></ul><p>【答案】</p><p>指针变量中存储的是虚拟地址，因为程序需要编译成机器码由 CPU 发出访存请求，而 CPU 只能发出虚拟地址访问请求</p><p>MIPS 汇编程序中 lw, sw 使用的是也是虚拟地址，因为本质上还是 CPU 访存</p><p><strong>Thinking 2.2</strong></p><ul><li>请从可重用性的角度，阐述用宏来实现链表的好处。</li><li>请你查看实验环境中的 <code>/usr/include/sys/queue.h</code> ，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</li></ul><p>【答案】</p><p>正如指导书中所说，C++ 和 Java 这些高级语言中有一种特性叫做<strong>泛型</strong>，可以通过实现模板类的方法对于不同的数据类型使用相同的代码</p><p>例如，C++ 中我们可以用下面的代码来实现一个栈</p><pre><code class="language-c++">template &lt;typename T&gt;
class Stack &#123;
    T data[1000];
    int top;
public:
    void push(T i);
    T pop();
&#125;
</code></pre><p>那么在定义的时候对于不同的数据类型，我们只需要定义</p><pre><code class="language-c++">Stack&lt;int&gt; stack1;
Stack&lt;double&gt; stack2;
Stack&lt;char&gt; stack3;
</code></pre><p>就可以对应不同类型的栈，这就实现了<strong>代码复用</strong></p><p>在 OS 实验中通过使用宏，我们也实现了代码复用，对于管理物理页面的 Pages 结构体，和后面 lab3 中可能需要管理用户进程的 Envs 结构体，我们无需重复相似的代码，使用列表宏，可以将两者分别串联成链表，这就是使用宏的好处</p><p>值得一提的是，C++ 的模板类是编译器在编译中替换的，<strong>对于不同的类型，编译器会新增加相应类型的代码</strong>，而我们实验使用宏，替换则是在预处理阶段实现的</p><p>在实验环境中查看 Linux 系统的内核源码，发现实验中的双向链表看上去是直接来自内核源码，下面比较单向链表、循环链表和双向链表</p><p>** 插入操作：** 单向链表插入操作十分简单，两行代码，双向链表插入操作一般运行四行代码，需要额外判断是否 next 指向了 NULL，循环链表与双向链表运行代码量基本相等，需额外判断是否 next 指向了头指针。特别的是，插入到头结点对三种链表而言性能相似，单向链表与双向链表插入到尾结点均要遍历完整个链表</p><p>** 删除操作：** 单向链表的删除操作复杂度为 O (n)，因为需要靠循环才能找到上一个链表节点的位置，双向链表及循环链表的删除操作与插入性能相近，也还是需要额外判断 NULL 或 HEAD。删除头结点对三种链表而言性能相似，而单向链表与双向链表删除尾结点还是要遍历所有节点</p><p><strong>Thinking 2.3</strong></p><p>请阅读 <code>include/queue.h</code> 以及 <code>include/pmap.h</code> , 将 <code>Page_list</code> 的结构梳理清楚，选择正确的展开结构</p><p>【答案】</p><p>本题选项略，展开后很容易看出选 C</p><p><strong>Thinking 2.4</strong></p><p>请你寻找上述两个 boot_* 函数在何处被调用</p><p>【答案】</p><p><code>boot_map_segment()</code> 函数在 <code>mips_vm_init()</code> 中被调用了两次：</p><p><img data-src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20220422210306931.png" alt="image-20220422210306931"></p><p>容易看出其目的是将 <code>pages</code> 结构体映射到虚拟地址 <code>UPAGES</code> 位置，将 <code>envs</code> 结构体映射到虚拟地址 <code>UENVS</code> 位置，这一映射也符合 <code>mmu.h</code> 中内存分布图示</p><p><code>boot_pgdir_walk()</code> 函数在 <code>boot_map_segment()</code> 中被调用：</p><p><img data-src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20220422210532528.png" alt="image-20220422210532528"></p><p>可以看出其目的是为了寻找虚拟地址 <code>va+i</code> 所对应的页表项，并返回对应项的虚拟地址， <code>boot_map_segment()</code> 中修改这一项的值从而建立映射</p><p>**Thinking 2.5 **</p><p>请你思考下述两个问题：</p><ul><li>请阅读上面有关 R3000-TLB 的叙述，从虚拟内存的实现角度，阐述 ASID 的必要性</li><li>请阅读《IDT R30xx Family Software Reference Manual》的 Chapter 6，结合 ASID 段的位数，说明 R3000 中可容纳不同的地址空间的最大数量</li></ul><p>【答案】</p><p>**ASID 的必要性：** 同一虚拟地址在不同地址空间中通常映射到不同物理地址，ASID 可以判断是在哪个地址空间。简要打比方来说，可能有多个进程都用到了这个虚拟地址，但该虚拟地址对应的数据大概率是不一样的，则因此指向的是不同物理地址，为了防止不同进程通过页表的错误数据访问到了错误的物理地址，因此添加了 ASID 这一标志位，这是对地址空间的一种保护。</p><p>** 可容纳不同地址空间的最大数量：**64 个，参考原文如下：</p><blockquote><p>Instead, the OS assigns a 6-bit unique code to each task’s distinct address space. Since the ASID is only 6 bits long, OS software does have to lend a hand if there are ever more than <strong>64 address spaces</strong> in concurrent use; but it probably won’t happen too often.</p></blockquote><p>**Thinking 2.6 **</p><p>请你完成如下三个任务：</p><ul><li>tlb_invalidate 和 tlb_out 的调用关系是怎样的？</li><li>请用一句话概括 tlb_invalidate 的作用</li><li>逐行解释 tlb_out 中的汇编代码</li></ul><p>【答案】</p><p><code>tlb_invalidate</code> 调用 <code>tlb_out</code></p><p>调用 <code>tlb_invalidate</code> 可以将该地址空间的虚拟地址对应的表项清除出去，一般用于这个虚拟空间引用次数为 0 时释放 TLB 空间</p><pre><code class="language-assembly">LEAF(tlb_out)
//1: j 1b
nop
     mfc0    k1,CP0_ENTRYHI  		//保存ENTRIHI原有值
     mtc0    a0,CP0_ENTRYHI  		//将传进来的参数放进ENTRYHI中
     nop
     tlbp							//检测ENTRYHI中的虚拟地址在tlb中是否有对应项
     nop
     nop
     nop
     nop
     mfc0    k0,CP0_INDEX    		//INDEX可以用来判断是否命中
     bltz    k0,NOFOUND  			//若k0最高位为1，即小于零，则表示未命中，则跳转的NOFOUND位置
     nop
     mtc0    zero,CP0_ENTRYHI    	//否则，将ENTRYHI清零
     mtc0    zero,CP0_ENTRYLO0   	//将ENTRYLO清零
     nop
     tlbwi						    //将清零后的两寄存器值写入到对应TLB项中， 相当于删除原有的TLB项
NOFOUND:
     mtc0    k1,CP0_ENTRYHI  		//将原来的ENTRYHI恢复
     
     j   ra  						//返回查询到的地址
     nop
END(tlb_out)
</code></pre><p><strong>Thinking 2.7</strong></p><p>在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位 ** 页 ****** 式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4 KB。由于 64 位系统中字长为 8 B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。因此在 64 位系统下，总共需要 3 × 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64 位。现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若记三级页表的基地址为 <code>PTbase</code> ，请你计算：</p><ul><li><p>三级页表页目录的基地址</p></li><li><p>映射到页目录自身的页目录项 (自映射)</p></li></ul><p>【答案】</p><p>不妨记页表基地址 (page table) 为 <code>PTbase</code></p><p><strong>页中间目录基地址 (page middle directory) <code>PMDbase</code> ：</strong> <code>(PTbase &gt;&gt; 12) &lt;&lt; 3 + PTbase</code></p><p><strong>页全局目录 (page global directory) <code>PGDbase</code> ：</strong> <code>(PTbase &gt;&gt; 21) &lt;&lt; 3 + PMDbase</code> <strong>（三级页表页目录的基地址）</strong></p><p><strong>页全局目录项（page global directory entry） <code>PGDE</code> ：</strong> <code>(PTbase &gt;&gt; 30) &lt;&lt; 3 + PGDbase</code> <strong>（自映射）</strong></p><p><strong>Thinking 2.8</strong></p><p>任选下述二者之一回答：</p><ul><li>简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。</li><li>简单了解并叙述 RISC-V 中的内存管理机制，比较 RISC-V 与 MIPS 在内存管理上的区别。</li></ul><p>【答案】</p><p>X86 体系结构中，以经典的 80386 处理器为例，下面内容整理自清华大学 ucore 操作系统实验指导书</p><p>80386 是 32 位的处理器，即可以寻址的物理内存地址空间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>=</mo><mn>4</mn><mi mathvariant="normal">G</mi></mrow><annotation encoding="application/x-tex">2^{32}=4 \mathrm{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord">4</span><span class="mord"><span class="mord mathrm">G</span></span></span></span></span> 字节。为更好理解面向 80386 处理器的 ucore 操作系统，需要用到三个地址空间的概念：物理地址、线性地址和逻辑地址。物理内存地址空间是处理器提交到总线上用于访问计算机系统中的内存和外设的最终地址。一个计算机系统中只有一个物理地址空间。线性地址空间是 80386 处理器通过段（Segment）机制控制下的形成的地址空间。在操作系统的管理下，每个运行的应用程序有相对独立的一个或多个内存空间段，每个段有各自的起始地址和长度属性，大小不固定，这样可让多个运行的应用程序之间相互隔离，实现对地址空间的保护。</p><p>在操作系统完成对 80386 处理器段机制的初始化和配置（主要是需要操作系统通过特定的指令和操作建立全局描述符表，完成虚拟地址与线性地址的映射关系）后，80386 处理器的段管理功能单元负责把虚拟地址转换成线性地址，在没有页机制启动的情况下，这个线性地址就是物理地址。</p><p>相对而言，段机制对大量应用程序分散地使用大内存的支持能力较弱。所以 Intel 公司又加入了页机制，每个页的大小是固定的（一般为 4KB），也可完成对内存单元的安全保护，隔离，且可有效支持大量应用程序分散地使用大内存的情况。</p><p>在操作系统完成对 80386 处理器页机制的初始化和配置（主要是需要操作系统通过特定的指令和操作建立页表，完成虚拟地址与线性地址的映射关系）后，应用程序看到的逻辑地址先被处理器中的段管理功能单元转换为线性地址，然后再通过 80386 处理器中的页管理功能单元把线性地址转换成物理地址。</p><p>显然，页机制和段机制有一定程度的功能重复，但 Intel 公司为了向下兼容等目标，使得这两者一直共存。</p><p>上述三种地址的关系如下：</p><ul><li>分段机制启动、分页机制未启动：逻辑地址 ---&gt;<strong> 段机制处理</strong> ---&gt; 线性地址 = 物理地址</li><li>分段机制和分页机制都启动：逻辑地址 ---&gt;<strong> 段机制处理</strong> ---&gt; 线性地址 ---&gt;<strong> 页机制处理</strong> ---&gt; 物理地址</li></ul><p>与我校的 MOS 操作系统实验相比，MIPS 的内存管理更为简单，仅有页机制，没有段机制处理</p><h2 id="实验难点展示"><a class="anchor" href="#实验难点展示">#</a> 实验难点展示</h2><h4 id="填写链表宏"><a class="anchor" href="#填写链表宏">#</a> 填写链表宏</h4><p><img data-src="https://img2022.cnblogs.com/blog/2785828/202204/2785828-20220413211113528-1529811000.png" alt="img"></p><p>作为实验的第一部分，我觉得这一部分对于我们的编程能力是一大挑战，因为在学习 C 语言的过程中，我们对宏的学习一般都是浅尝辄止，并没有深入系统的进行了解，就像上一个 lab 中对于可变长参数列表的理解一样，这都属于语言层面的障碍</p><p>同时在数据结构课程中，我们实现的链表都是单一类型的，而这一次我们通过宏来实现了<em>泛型</em>，这是实验中需要转变的一个思想，在链表宏中，我们把数据和连接项分开，数据就是 <code>Page</code> 结构体中 <code>ref</code> 等变量，而连接项 <code>pp_link</code> 是由 <code>LIST_ENTRY</code> 宏指定的，对于任何一种数据结构组成链表都相同的 <code>le_next</code> 和 <code>le_prev</code></p><p>除此之外，填写链表的插入和删除都是数据结构课程中老生常谈的话题，难度不是很大。在实验的一个任务中，我们需要将元素插入链表的尾部，解答本题使用的<strong>利用 elm 中的 elm-&gt;field.le_next 指针做跳板，把 elm 跳到链表尾</strong>的方法非常的巧妙，是一个难点</p><p><em>关于链表宏的疑惑</em>：为什么 <code>le_prev</code> 指向的不是上一个节点，而是上一个节点的 <code>pp_link</code> 中的 <code>le_next</code> ？这样难道不就很难去访问上一个节点了吗，是否背离了使用双向链表的初衷？（当然这样删除和插入还是相当方便的，为什么不指向上一个节点，让访问上一个节点也变得这样方便呢？）</p><h4 id="物理内存管理"><a class="anchor" href="#物理内存管理">#</a> 物理内存管理</h4><p><img data-src="https://nieyong.github.io/wiki_cpu/CPU%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-image/cpu_memory_map/MIPS_mem_map.png" alt="See the source image"></p><p><img data-src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20220424200402392.png" alt="image-20220424200402392"></p><p>物理内存管理部分，我认为最大的难点在于混淆了物理内存和虚拟内存的位置。在我的印象中，我认为物理内存应当是像虚拟内存那样整齐的分层的一块一块排列好的，然后对应的填进去就可以了，简单来说也就是物理内存也应当是分块的，排列成像上图那样。</p><p>但是实际上不是这样，理解物理内存分配要从理解 <code>extern char end[]</code> 这句话开始，我们在链接脚本中规定了 <code>end=0x80400000</code> ，就像上图中的虚拟内存图中 <code>end</code> 的位置一样，然后物理内存对于操作系统而言就仿佛像是一根长长的木棍，它就是 <code>end</code> 数组，然后当我们需要的时候（比如在 <code>alloc</code> 函数中），我们需要多少，就从这个木棍中切下来多少，然后 <code>freemem</code> 这个变量始终指向木棍开始的位置，在一开始操作系统尚未建立分页的时候，我们就是这样<em>从木棍上切下来了</em> <strong>pages 结构体数组和 env 结构体数组的内存空间，还有内核的页目录的内存空间，以及建立映射时可能需要的页表的内存空间</strong></p><p>理解完这个以后，对物理内存的其它部分就不难理解了</p><h4 id="虚拟内存管理"><a class="anchor" href="#虚拟内存管理">#</a> 虚拟内存管理</h4><p>这一部分最难理解的就是自映射部分...... 理论课上讲的差不多了，仔细想想还是不难理解的，不能说是难点</p><p>用户进程拥有属于自己的页表，就存在上图中的 <code>UVPT</code> 的位置，这个我一开始是不知道的，也算是理解上的难点，即用户页表和内核页表是分开的，显然用户页表连续，因此可以进行自映射，但是内核页表在上文中分析过了，是需要的时候就切一块，因此不连续，也不知道映射到了虚拟内存的什么位置，因此不会有自映射</p><h2 id="指导书反馈"><a class="anchor" href="#指导书反馈">#</a> 指导书反馈</h2><p>应该也有很多同学在讨论区和群里提到这个问题了，当在 <code>pgdir_walk</code> 中分配了一页后，需要将其对应的页控制块的引用加 1，但是给出的框架中没有提示去补这行代码，如下图所示：</p><p><img data-src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20220424202727262.png" alt="image-20220424202727262"></p><div class="tags"><a href="/tags/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="ic i-tag"></i> 北航操作系统</a> <a href="/tags/OS/" rel="tag"><i class="ic i-tag"></i> OS</a> <a href="/tags/Lab2/" rel="tag"><i class="ic i-tag"></i> Lab2</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-06-15 21:28:29" itemprop="dateModified" datetime="2022-06-15T21:28:29+08:00">2022-06-15</time> </span><span id="2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab2/" class="item leancloud_visitors" data-flag-title="BUAA-OS Lab2 实验总结" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="FL 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="FL 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="FL 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>FL <i class="ic i-at"><em>@</em></i>FlyingLandlord's Blog</li><li class="link"><strong>本文链接：</strong> <a href="http://flyinglandlord.github.io/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab2/" title="BUAA-OS Lab2 实验总结">http://flyinglandlord.github.io/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab2/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/06/15/BUAA-OS-2022/lab3/doc-lab3/" itemprop="url" rel="prev" data-background-image="&#x2F;assets&#x2F;BangD.jpg" title="BUAA-OS Lab3实验总结"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 北航操作系统</span><h3>BUAA-OS Lab3实验总结</h3></a></div><div class="item right"><a href="/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab1/" itemprop="url" rel="next" data-background-image="&#x2F;assets&#x2F;BangD.jpg" title="BUAA-OS Lab1实验总结"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 北航操作系统</span><h3>BUAA-OS Lab1实验总结</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#lab-2-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">lab-2 实验总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%A2%98%E8%A7%A3%E7%AD%94"><span class="toc-number">1.1.</span> <span class="toc-text">思考题解答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E9%9A%BE%E7%82%B9%E5%B1%95%E7%A4%BA"><span class="toc-number">1.2.</span> <span class="toc-text">实验难点展示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A1%AB%E5%86%99%E9%93%BE%E8%A1%A8%E5%AE%8F"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">填写链表宏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">物理内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">虚拟内存管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AF%BC%E4%B9%A6%E5%8F%8D%E9%A6%88"><span class="toc-number">1.3.</span> <span class="toc-text">指导书反馈</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/04/22/BUAA-OS-2022/lab0-lab2/lab0-lab2_Summary/" rel="bookmark" title="lab0-lab2总结">lab0-lab2总结</a></li><li><a href="/2022/04/29/BUAA-OS-2022/lab0-lab2/lab2-quiz/" rel="bookmark" title="BUAA-OS Lab2上机">BUAA-OS Lab2上机</a></li><li><a href="/2022/04/29/BUAA-OS-2022/lab3/lab3-quiz/" rel="bookmark" title="BUAA-OS Lab3上机">BUAA-OS Lab3上机</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab0/" rel="bookmark" title="BUAA-OS Lab0实验总结">BUAA-OS Lab0实验总结</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab1/" rel="bookmark" title="BUAA-OS Lab1实验总结">BUAA-OS Lab1实验总结</a></li><li class="active"><a href="/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab2/" rel="bookmark" title="BUAA-OS Lab2实验总结">BUAA-OS Lab2实验总结</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab3/doc-lab3/" rel="bookmark" title="BUAA-OS Lab3实验总结">BUAA-OS Lab3实验总结</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab4/doc-lab4/" rel="bookmark" title="BUAA-OS Lab4实验总结">BUAA-OS Lab4实验总结</a></li><li><a href="/2022/06/15/BUAA-OS-2022/lab5/doc-lab5/" rel="bookmark" title="BUAA-OS Lab5实验总结">BUAA-OS Lab5实验总结</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="FL" data-src="/images/avatar.jpg"><p class="name" itemprop="name">FL</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">32</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">5</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">36</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZseWluZ2xhbmRsb3Jk" title="https:&#x2F;&#x2F;github.com&#x2F;flyinglandlord"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjI2NDUzNzcxNjFAcXEuY29t" title="mailto:2645377161@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/06/15/BUAA-OS-2022/lab3/doc-lab3/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab1/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/11/10/BUAA-CO-2021/P3/P3%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95%E6%B8%B8%E8%AE%B0/" title="P3课上测试游记">P3课上测试游记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/11/13/BUAA-CO-2021/P4/CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/" title="P4课下学习—单周期CPU设计(2)">P4课下学习—单周期CPU设计(2)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/10/20/BUAA-CO-2021/P0/P0%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95%E6%B8%B8%E8%AE%B0/" title="P0课上测试游记">P0课上测试游记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/10/24/BUAA-CO-2021/P1/P1%E8%AF%BE%E4%B8%8B%E5%AD%A6%E4%B9%A0/" title="P1课下学习">P1课下学习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/09/25/BUAA-CO-2021/Pre/Verilog%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%83%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93(Part2)/" title="Verilog 学习笔记（2）">Verilog 学习笔记（2）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="分类于 北航操作系统">北航操作系统</a></div><span><a href="/2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab1/" title="BUAA-OS Lab1实验总结">BUAA-OS Lab1实验总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/10/27/BUAA-CO-2021/P1/P1%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95%E6%B8%B8%E8%AE%B0/" title="P1课上测试游记">P1课上测试游记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/11/01/BUAA-CO-2021/P2/P2%E8%AF%BE%E4%B8%8B%E5%AD%A6%E4%B9%A0/" title="P2课下学习">P2课下学习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/09/25/BUAA-CO-2021/Pre/%E5%85%B3%E4%BA%8ECPU%E8%BE%93%E5%87%BA%E5%BA%8F%E5%88%97%E6%A3%80%E6%9F%A5%E9%A2%98%E7%9A%84%E8%B0%83%E8%AF%95%E5%BB%BA%E8%AE%AE/" title="CPU输出序列检查调试方法">CPU输出序列检查调试方法</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 北航计算机组成原理">北航计算机组成原理</a></div><span><a href="/2021/11/13/BUAA-CO-2021/P3/CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/" title="P3课下学习—单周期CPU设计(1)">P3课下学习—单周期CPU设计(1)</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">FL @ Test Blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/06/15/BUAA-OS-2022/lab0-lab2/doc-lab2/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>